<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Game Collection - Multiplayer</title>
    <script>
      window.onSpotifyWebPlaybackSDKReady = function() {};
    </script>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Add Spotify Web Playback SDK -->
    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .title {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .screen {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: rgba(15, 52, 96, 0.8);
            border-radius: 15px;
            padding: 2rem;
            margin: 1rem 0;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .input-group {
            margin: 1rem 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .input-group input, .input-group select, .input-group textarea {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }

        .input-group input::placeholder, .input-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 0.5rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .btn-primary { background: linear-gradient(45deg, #27ae60, #2ecc71); }
        .btn-danger { background: linear-gradient(45deg, #e74c3c, #c0392b); }
        .btn-warning { background: linear-gradient(45deg, #f39c12, #e67e22); }
        .btn-info { background: linear-gradient(45deg, #8e44ad, #9b59b6); }
        .btn-secondary { background: linear-gradient(45deg, #95a5a6, #7f8c8d); }
        .btn-bot { background: linear-gradient(45deg, #16a085, #1abc9c); }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn:disabled:hover {
            transform: none !important;
            box-shadow: none !important;
        }

        .players-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .player-card {
            background: rgba(52, 73, 94, 0.8);
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        .player-card.host {
            border-color: #f39c12;
        }

        .player-card.ready {
            border-color: #27ae60;
        }

        .player-card.current-turn {
            border-color: #e74c3c;
            animation: pulse 2s infinite;
        }

        .player-card.bot {
            border-color: #1abc9c;
            background: rgba(22, 160, 133, 0.3);
        }

        .kick-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }

        .player-card:hover .kick-btn {
            display: block;
        }

        .kick-btn:hover {
            background: rgba(231, 76, 60, 1);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .info-card {
            background: rgba(52, 73, 94, 0.6);
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
        }

        .question-section {
            background: rgba(26, 26, 46, 0.8);
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
        }

        .ready-to-vote-section {
            background: rgba(241, 196, 15, 0.2);
            border: 2px solid #f1c40f;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .ready-to-vote-section p {
            margin: 0 0 10px 0;
            font-weight: bold;
            color: #f1c40f;
        }

        .ready-to-vote-section .ready-count {
            font-size: 1.2em;
            color: #fff;
            margin: 10px 0;
        }

        .game-log {
            background: rgba(52, 73, 94, 0.4);
            padding: 1rem;
            border-radius: 10px;
            height: 300px;
            overflow-y: auto;
            margin: 1rem 0;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .log-entry {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
        }

        .voting-section {
            background: rgba(231, 76, 60, 0.2);
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
            border: 2px solid rgba(231, 76, 60, 0.5);
        }

        .locations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.4rem;
            margin: 1rem 0;
            font-size: 0.8rem;
            max-height: 150px;
            overflow-y: auto;
        }

        .location-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem;
            border-radius: 5px;
            text-align: center;
        }

        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            color: #e74c3c;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .success {
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid #27ae60;
            color: #27ae60;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .warning {
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid #f39c12;
            color: #f39c12;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .info {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            color: #3498db;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .role-display {
            font-size: 1.2rem;
            font-weight: bold;
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            margin: 1rem 0;
        }

        .role-imposter {
            background: rgba(231, 76, 60, 0.3);
            border: 2px solid #e74c3c;
            color: #e74c3c;
        }

        .role-location {
            background: rgba(39, 174, 96, 0.3);
            border: 2px solid #27ae60;
            color: #27ae60;
        }

        .lock-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            margin-left: 1rem;
        }

        .lock-status.locked {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        .lock-status.unlocked {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
            border: 1px solid #27ae60;
        }

        .bot-controls {
            background: rgba(22, 160, 133, 0.2);
            border: 2px solid #1abc9c;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .bot-controls h3 {
            color: #1abc9c;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bot-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .bot-warning {
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid #f39c12;
            color: #f39c12;
            padding: 0.75rem;
            border-radius: 8px;
            margin: 0.5rem 0;
            font-size: 0.9rem;
        }

        .scoreboard {
            background: rgba(15, 52, 96, 0.8);
            border-radius: 15px;
            padding: 1.5rem;
            margin: 1rem 0;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .scoreboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .scoreboard-table th,
        .scoreboard-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scoreboard-table th {
            background: rgba(255, 255, 255, 0.1);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
        }

        .scoreboard-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .rank {
            font-weight: bold;
            color: #f39c12;
        }

        .rank.first { color: #f1c40f; }
        .rank.second { color: #95a5a6; }
        .rank.third { color: #e67e22; }

        .player-name {
            font-weight: bold;
        }

        .player-name.offline {
            opacity: 0.6;
            font-style: italic;
        }

        .player-name.bot {
            color: #1abc9c;
        }

        .score {
            font-weight: bold;
            color: #27ae60;
            font-size: 1.1rem;
        }

        .scoreboard-tabs {
            display: flex;
            margin-bottom: 1rem;
        }

        .tab-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            margin-right: 0.5rem;
            transition: all 0.3s ease;
        }

        .tab-btn.active {
            background: rgba(52, 152, 219, 0.6);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .game-history {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .round-summary {
            background: rgba(39, 174, 96, 0.2);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border: 1px solid rgba(39, 174, 96, 0.4);
        }

        .round-summary h4 {
            color: #27ae60;
            margin-bottom: 0.5rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #spotify-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
        }

        #spotify-popup.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #spotify-popup .modal-content {
            width: 1000px;
            max-width: 90vw;
            height: 700px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 2rem;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content.large {
            max-width: 800px;
        }

        .question-status-waiting {
            color: #f39c12 !important;
        }

        .question-status-asked {
            color: #e74c3c !important;
        }

        .question-status-ready {
            color: #27ae60 !important;
        }

        .question-status-asking {
            color: #3498db !important;
        }

        /* NEW: Game selection styles */
        .game-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .game-option {
            background: rgba(15, 52, 96, 0.8);
            border-radius: 15px;
            padding: 2rem;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .game-option:hover {
            transform: translateY(-5px);
            border-color: rgba(52, 152, 219, 0.6);
            box-shadow: 0 10px 30px rgba(52, 152, 219, 0.3);
        }

        .game-option h3 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: #3498db;
        }

        .game-option p {
            margin-bottom: 1.5rem;
            opacity: 0.8;
        }

        .game-option .emoji {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* Hint section styles */
        .hint-section {
            background: rgba(26, 26, 46, 0.8);
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
        }

        /* NEW: Autocomplete styles for imposter guess input */
        .autocomplete-container {
            position: relative;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .autocomplete-suggestion {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.2s ease;
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background: rgba(52, 152, 219, 0.3);
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .imposter-guess-hint {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.5rem;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .container {
                padding: 10px;
            }
            
            .game-info {
                grid-template-columns: 1fr;
            }

            .bot-status {
                flex-direction: column;
                gap: 0.5rem;
            }

            .game-selection {
                grid-template-columns: 1fr;
            }
        }

        /* NEW: Room type styles */
        .room-type-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            margin-left: 1rem;
        }

        .room-type-status.public {
            background: rgba(52, 152, 219, 0.2);
            color: #3498db;
            border: 1px solid #3498db;
        }

        .room-type-status.private {
            background: rgba(243, 156, 18, 0.2);
            color: #f39c12;
            border: 1px solid #f39c12;
        }

        .room-type-status.locked {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        .room-type-controls {
            background: rgba(52, 73, 94, 0.2);
            border: 2px solid #34495e;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .room-type-controls h3 {
            color: #34495e;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .room-type-options {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .room-type-btn {
            flex: 1;
            min-width: 120px;
            transition: all 0.3s ease;
        }

        .room-type-btn.active {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .room-type-description {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
            font-style: italic;
        }

        /* Spotify Music Styles */
        .track-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .track-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .track-artwork {
            width: 50px;
            height: 50px;
            border-radius: 6px;
            margin-right: 1rem;
            object-fit: cover;
        }

        .track-info {
            flex: 1;
            min-width: 0;
        }

        .track-name {
            font-weight: bold;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-artist {
            font-size: 0.9rem;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Progress Bar Styling */
        #spotify-progress-bar {
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            border-radius: 2px;
            height: 4px;
        }

        #spotify-progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #1db954;
            cursor: pointer;
            border: none;
        }

        #spotify-progress-bar::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #1db954;
            cursor: pointer;
            border: none;
        }

        #spotify-progress-bar:hover::-webkit-slider-thumb {
            background: #1ed760;
        }

        #spotify-progress-bar:hover::-moz-range-thumb {
            background: #1ed760;
        }

        .playlist-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .playlist-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .playlist-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .playlist-artwork {
            width: 120px;
            height: 120px;
            border-radius: 8px;
            margin: 0 auto 0.5rem;
            object-fit: cover;
        }

        .no-image {
            width: 120px;
            height: 120px;
            border-radius: 8px;
            margin: 0 auto 0.5rem;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .playlist-name {
            font-weight: bold;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playlist-tracks {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #1db954;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spotify-tab-btn.active {
            background: #1db954 !important;
            color: white !important;
        }

        /* Search tab styles */
        .search-tab-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .search-tab-btn.active {
            background: #1db954 !important;
            color: white !important;
        }

        .search-tab-content {
            max-height: 60vh;
            overflow-y: auto;
        }

        /* Public lobbies styles */
        .public-lobby-item {
            background: rgba(52, 73, 94, 0.8);
            padding: 1rem;
            border-radius: 10px;
            margin: 0.5rem 0;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .public-lobby-item:hover {
            border-color: rgba(52, 152, 219, 0.6);
            transform: translateY(-2px);
        }

        .public-lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .public-lobby-code {
            font-weight: bold;
            font-size: 1.2rem;
            color: #3498db;
        }

        .public-lobby-game-type {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .public-lobby-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .public-lobby-detail {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .public-lobby-detail.bots {
            color: #1abc9c;
        }

        .public-lobby-detail.custom {
            color: #f39c12;
        }

        .public-lobby-detail.players {
            color: #27ae60;
        }

        .public-lobby-detail.time {
            color: #95a5a6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">üéÆ GAME COLLECTION - Multiplayer</h1>

        <!-- NEW: Game Selection Screen -->
        <div id="game-selection-screen" class="screen active">
            <div class="card">
                <h2>Choose Your Game</h2>
                <p>Select which game you'd like to play with your friends!</p>
                
                <div class="input-group">
                    <label>Your Name:</label>
                    <input type="text" id="global-player-name" placeholder="Enter your name" maxlength="20">
                    <div id="name-error" style="color:#e74c3c; font-size:1rem; margin-top:0.5rem; display:none;"></div>
                </div>

                <div class="game-selection">
                    <div class="game-option">
                        <div class="emoji">üïµÔ∏è</div>
                        <h3>The Mole</h3>
                        <p>Find the imposter among locations. Ask questions and vote out the mole!</p>
                        <button class="btn btn-primary" id="play-mole-btn">Play The Mole</button>
                    </div>

                    <div class="game-option">
                        <div class="emoji">üèÄ</div>
                        <h3>NBA Imposter</h3>
                        <p>Guess NBA players by giving hints. Find who doesn't belong!</p>
                        <button class="btn btn-primary" id="play-nba-btn">Play NBA Imposter</button>
                    </div>

                    <div class="game-option">
                        <div class="emoji">üé§</div>
                        <h3>Rapper Imposter</h3>
                        <p>Guess rappers by giving hints. Find who doesn't know the artist!</p>
                        <button class="btn btn-primary" id="play-rapper-btn">Play Rapper Imposter</button>
                    </div>
                </div>

            </div>
        </div>

        <!-- Home Screen -->
        <div id="home-screen" class="screen">
            <div class="card">
                <h2 id="game-title">Welcome to The Game!</h2>
                <p id="game-description">Game description</p>
                
                <div class="input-group">
                    <label>Your Name:</label>
                    <input type="text" id="player-name" placeholder="Enter your name" maxlength="20">
                </div>

                <div style="text-align: center; margin-top: 2rem;">
                    <button class="btn btn-primary" onclick="createRoom()">üéÆ Create Room</button>
                    <button class="btn btn-warning" onclick="showJoinRoom()">üö™ Join Room</button>
                    <button class="btn btn-secondary" onclick="backToGameSelection()">‚Üê Back to Game Selection</button>
                </div>

                <div id="join-room-section" style="display: none; margin-top: 1rem;">
                    <div class="input-group">
                        <label>Room Code:</label>
                        <input type="text" id="room-code" placeholder="Enter room code" maxlength="6">
                    </div>
                    <button class="btn btn-primary" onclick="joinRoom()">Join</button>

                    <!-- Public Lobbies Browser -->
                    <div id="public-lobbies-section" style="margin-top: 2rem;">
                        <h3>üåê Public Lobbies</h3>
                        <div id="public-lobbies-list"></div>
                    </div>
                </div>

                <!-- Spotify Integration -->
                <div id="spotify-section" style="text-align:center; margin-top:2rem;">
                    <button id="spotify-login-btn" class="btn btn-info">
                        <img src="https://developer.spotify.com/assets/branding-guidelines/icon3@2x.png" alt="Spotify" style="height:20px;vertical-align:middle;margin-right:8px;" onerror="this.style.display='none';">
                        Login with Spotify
                    </button>
                    <button id="spotify-open-music-btn" class="btn btn-info" style="display:none;">üéµ Open Music</button>
                </div>

                <script>
                    // Persistent Spotify tab navigation
                    (function() {
                        function activateSpotifyTab(tab) {
                            const main = document.getElementById('spotify-main');
                            document.querySelectorAll('.spotify-tab-btn').forEach(btn => btn.classList.remove('active'));
                            document.querySelector('.spotify-tab-btn[data-tab="' + tab + '"]').classList.add('active');
                            
                            // Clear dashboard updates when switching away
                            if (tab !== 'home' && spotifyDashboardUpdateInterval) {
                                clearInterval(spotifyDashboardUpdateInterval);
                                spotifyDashboardUpdateInterval = null;
                                console.log('üéµ Stopped periodic updates for currently playing');
                            }
                            
                            if (tab === 'home') {
                                showSpotifyHome();
                            } else if (tab === 'playlists') {
                                showSpotifyLibrary();
                            } else if (tab === 'study') {
                                showSpotifyStudyStats();
                            } else if (tab === 'recommendations') {
                                showSpotifyStudyRecommendations();
                            } else if (tab === 'search') {
                                // Render search UI
                                main.innerHTML = `<h2>üîç Search Spotify</h2>
                                    <div style='margin-bottom:1rem;'>
                                        <input id='spotify-app-search-input' type='text' placeholder='Search tracks, artists, albums...' style='width:60%;padding:10px;font-size:1rem;border-radius:8px;border:none;background:#232b3e;color:white;' onkeypress='handleSearchKeyPress(event)'>
                                        <button class='btn btn-primary' onclick='searchSpotifyApp()'>Search</button>
                                    </div>
                                    <div id='spotify-search-tabs' style='display:none;'>
                                        <div class='search-tab-buttons' style='display:flex;gap:0.5rem;margin-bottom:1rem;'>
                                            <button class='btn btn-info search-tab-btn active' data-search-tab='tracks' onclick='showSearchTab("tracks")'>üéµ Songs</button>
                                            <button class='btn btn-info search-tab-btn' data-search-tab='albums' onclick='showSearchTab("albums")'>üíø Albums</button>
                                            <button class='btn btn-info search-tab-btn' data-search-tab='artists' onclick='showSearchTab("artists")'>üé§ Artists</button>
                                        </div>
                                        <div id='search-tab-tracks' class='search-tab-content active'></div>
                                        <div id='search-tab-albums' class='search-tab-content' style='display:none;'></div>
                                        <div id='search-tab-artists' class='search-tab-content' style='display:none;'></div>
                                    </div>
                                    <div id='spotify-app-search-results'></div>`;
                                // Add focus to search input
                                setTimeout(() => {
                                    const searchInput = document.getElementById('spotify-app-search-input');
                                    if (searchInput) searchInput.focus();
                                }, 100);
                            }
                        }
                        document.addEventListener('DOMContentLoaded', function() {
                            document.querySelectorAll('.spotify-tab-btn').forEach(btn => {
                                btn.onclick = function() {
                                    activateSpotifyTab(this.getAttribute('data-tab'));
                                };
                            });
                        });
                        // Expose for programmatic switching
                        window.activateSpotifyTab = activateSpotifyTab;
                        // Patch showSpotifyDashboard etc to also update tab active state
                        window.showSpotifyDashboard = function() {
                            activateSpotifyTab('home');
                            renderSpotifyHome();
                        };
                        window.showSpotifyLibrary = function() {
                            activateSpotifyTab('playlists');
                            loadSpotifyPlaylistsApp();
                        };
                        window.showSpotifySearch = function() {
                            activateSpotifyTab('search');
                            // UI rendered in activateSpotifyTab
                        };
                    })();
                </script>
                </div>
                </div>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobby-screen" class="screen">
            <div class="card">
                <div style="display: flex; align-items: center; margin-bottom: 1rem;">
                    <h2>Room: <span id="room-display"></span></h2>
                    <div id="room-type-display" class="room-type-status">
                        <!-- Room type will be displayed here -->
                    </div>
                </div>
                <div id="lobby-players" class="players-list"></div>
                
                <!-- Bot Controls Section (only for The Mole) -->
                <div id="bot-controls" class="bot-controls" style="display: none;">
                    <h3>ü§ñ Bot Management</h3>
                    <div class="bot-status">
                        <span>Bots in room: <strong id="bot-count">0</strong></span>
                        <div>
                            <button id="add-bot-btn" class="btn btn-bot" onclick="addBot()">ü§ñ Add Bot</button>
                            <button id="remove-all-bots-btn" class="btn btn-secondary" onclick="removeAllBots()" style="display: none;">Remove All Bots</button>
                        </div>
                    </div>
                    <div id="bot-warning" class="bot-warning" style="display: none;">
                        ‚ö†Ô∏è Bots will be automatically removed if you set custom locations
                    </div>
                </div>

                <!-- NEW: Room Type Controls (host only) -->
                <div id="room-type-controls" class="room-type-controls" style="display: none;">
                    <h3>üîí Room Settings</h3>
                    <div class="room-type-options">
                        <button class="btn btn-primary room-type-btn" onclick="changeRoomType('public')" data-type="public">
                            üåê Public
                        </button>
                        <button class="btn btn-warning room-type-btn" onclick="changeRoomType('private')" data-type="private">
                            üîí Private
                        </button>
                        <button class="btn btn-danger room-type-btn" onclick="changeRoomType('locked')" data-type="locked">
                            üö´ Locked
                        </button>
                    </div>
                    <p class="room-type-description" id="room-type-description">
                        Public rooms are visible in the lobby browser and joinable by code.
                    </p>
                </div>
                
                <div style="text-align: center; margin-top: 2rem;">
                    <button id="ready-btn" class="btn btn-warning" onclick="toggleReady()">Ready Up</button>
                    <button id="start-btn" class="btn btn-primary" onclick="startGame()" style="display: none;">üéÆ Start Game</button>
                    <button id="custom-locations-btn" class="btn btn-info" onclick="showCustomLocations()" style="display: none;">üéØ Custom Locations</button>
                    <button class="btn btn-info" onclick="showScoreboard()">üìä Scoreboard</button>
                    <button class="btn btn-secondary" onclick="backToGameSelection()">‚Üê Back to Game Selection</button>
                </div>

                <!-- Spotify Integration -->
                <div id="spotify-section-lobby" style="text-align:center; margin-top:2rem;">
                    <button id="spotify-login-btn-lobby" class="btn btn-info">
                        <img src="https://developer.spotify.com/assets/branding-guidelines/icon3@2x.png" alt="Spotify" style="height:20px;vertical-align:middle;margin-right:8px;" onerror="this.style.display='none';">
                        Login with Spotify
                    </button>
                    <button id="spotify-open-music-btn-lobby" class="btn btn-info" style="display:none;">üéµ Open Music</button>
                </div>
            </div>

            <div class="scoreboard">
                <h3>üèÜ Room Scoreboard</h3>
                <div id="lobby-scoreboard-content">
                    <p>No games played yet. Start your first game!</p>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <div class="game-info">
                <div class="info-card">
                    <h3>Game Status</h3>
                    <p>Round: <span id="current-round">1</span></p>
                    <p id="questions-display">Questions: <span id="questions-count">0/5</span></p>
                    <p id="hints-display" style="display: none;">Hints: <span id="hints-count">0/5</span></p>
                    <p>Turn: <span id="current-turn">-</span></p>
                </div>
                
                <div class="info-card">
                    <h3>Players</h3>
                    <div id="game-players" class="players-list"></div>
                </div>

                <div class="info-card" id="game-locations-card">
                    <h3 id="game-items-title">üìç Possible Locations</h3>
                    <div id="game-locations-list" class="locations-grid"></div>
                </div>
            </div>

            <div id="role-display" class="role-display"></div>

            <!-- Question Section (The Mole only) -->
            <div class="question-section" id="question-section">
                <h3>‚ùì Current Question</h3>
                <div id="current-question" style="margin: 1rem 0; font-style: italic;">Waiting for question...</div>
                
                <div id="ask-section" style="display: none;">
                    <div class="input-group">
                        <label>Ask:</label>
                        <select id="target-select">
                            <option value="">Select player to ask</option>
                        </select>
                    </div>
                    <button id="ask-question-btn" class="btn btn-primary" onclick="askQuestion()">üé≤ Ask Question</button>
                    <div id="question-status" style="margin-top: 0.5rem; font-style: italic; color: rgba(255,255,255,0.7); display: none;">
                        <!-- Status messages will appear here -->
                    </div>
                </div>

                <!-- Answer Input Section (for when answering questions directly on screen) -->
                <div id="answer-input-section" style="display: none;">
                    <div class="input-group">
                        <label id="answer-question-label">Answer the question:</label>
                        <div id="answer-question-text" style="background: rgba(255,255,255,0.1); padding: 0.5rem; border-radius: 5px; margin-bottom: 0.5rem; font-style: italic;"></div>
                        <textarea id="answer-input-screen" rows="3" placeholder="Type your answer here..."></textarea>
                    </div>
                    <button id="submit-answer-btn" class="btn btn-primary" onclick="submitAnswerFromScreen()">üìù Submit Answer</button>
                    <button id="cancel-answer-btn" class="btn btn-secondary" onclick="cancelAnswerFromScreen()">Cancel</button>
                </div>

                <div id="imposter-reveal-section" style="display: none;">
                    <button class="btn btn-danger" onclick="showImposterReveal()">üé≠ Reveal as Imposter</button>
                </div>

                <!-- Answer Log Section -->
                <div id="answer-log-section" style="margin-top: 2rem;">
                    <h3>üìã Question & Answer Log</h3>
                    <div id="answer-log" style="max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 10px; padding: 1rem;">
                        <div id="no-questions-yet" style="text-align: center; color: rgba(255,255,255,0.5); font-style: italic;">
                            No questions asked yet...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hint Section (NBA/Rapper Imposter only) -->
            <div class="hint-section" id="hint-section" style="display: none;">
                <h3 id="hint-title">üí° Give a Hint</h3>
                <div id="current-hint-display" style="margin: 1rem 0; font-style: italic;">Waiting for hints...</div>
                
                <div id="give-hint-section" style="display: none;">
                    <div class="input-group">
                        <label id="hint-label">Your Hint:</label>
                        <textarea id="hint-input" rows="3" placeholder="Give a hint about your player..."></textarea>
                    </div>
                    <button id="give-hint-btn" class="btn btn-primary" onclick="giveHint()">üí° Give Hint</button>
                </div>

                <div id="imposter-guess-section" style="display: none;">
                    <button class="btn btn-danger" onclick="showImposterGuess()">üé≠ Guess as Imposter</button>
                </div>
            </div>

            <div id="ready-to-vote-section" class="ready-to-vote-section" style="display: none;">
                <p>üó≥Ô∏è Ready to start voting?</p>
                <div class="ready-count" id="ready-count-display">0 players ready</div>
                <p>At least <span id="required-count">2</span> players need to be ready before voting begins.</p>
                <button id="ready-to-vote-btn" class="btn btn-warning" onclick="readyToVote()">I'm Ready to Vote!</button>
            </div>

            <div id="voting-section" class="voting-section" style="display: none;">
                <h3>üó≥Ô∏è Vote for the Imposter</h3>
                <p>Choose who you think is the imposter:</p>
                <div id="vote-options"></div>
            </div>

            <div class="scoreboard">
                <h3>üìä Current Scores</h3>
                <div id="game-scoreboard-content"></div>
                <button class="btn btn-info" onclick="showScoreboard()">View Full Scoreboard</button>
            </div>

            <!-- Spotify Integration -->
            <div id="spotify-section-game" style="text-align:center; margin-top:2rem;">
                <button id="spotify-login-btn-game" class="btn btn-info">
                    <img src="https://developer.spotify.com/assets/branding-guidelines/icon3@2x.png" alt="Spotify" style="height:20px;vertical-align:middle;margin-right:8px;" onerror="this.style.display='none';">
                    Login with Spotify
                </button>
                <button id="spotify-open-music-btn-game" class="btn btn-info" style="display:none;">üéµ Open Music</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen">
            <div class="card">
                <h2>üèÅ Game Over!</h2>
                <div id="game-result"></div>
                <div id="game-summary"></div>
                <button class="btn btn-primary" onclick="backToLobby()">Back to Lobby</button>

                <!-- Spotify Integration -->
                <div id="spotify-section-gameover" style="text-align:center; margin-top:2rem;">
                    <button id="spotify-login-btn-gameover" class="btn btn-info">
                        <img src="https://developer.spotify.com/assets/branding-guidelines/icon3@2x.png" alt="Spotify" style="height:20px;vertical-align:middle;margin-right:8px;" onerror="this.style.display='none';">
                        Login with Spotify
                    </button>
                    <button id="spotify-open-music-btn-gameover" class="btn btn-info" style="display:none;">üéµ Open Music</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    
    <!-- Spotify Music Modal -->
    <div id="spotify-popup" class="modal">
        <div class="modal-content" style="padding:0; border-radius:15px; overflow:hidden; width:1000px; max-width:90vw; height:700px;">
            <!-- Header -->
            <div style="background:linear-gradient(45deg, #1db954, #1ed760); padding:1rem; border-radius:15px 15px 0 0; display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0; color:white;">üéµ Spotify Music</h2>
                <div style="display:flex; gap:0.5rem;">
                    <button class="btn btn-danger" onclick="hideModal('spotify-popup')" style="background:rgba(255,255,255,0.2); border:none;">‚úï</button>
                </div>
            </div>
            
            <!-- Main Content -->
            <div style="display:flex; flex:1; min-height:0;">
                <!-- Sidebar -->
                <div id="spotify-sidebar" style="flex-shrink:0; width:240px; min-width:240px; background:#181e2a; display:flex; flex-direction:column; padding:0.8rem; border-right:2px solid #222; box-sizing:border-box;">
                    <div id="spotify-user-profile" style="margin-bottom:1.5rem; text-align:center;"></div>
                    <button class="btn btn-info spotify-tab-btn active" data-tab="home" style="width:100%;margin-bottom:0.5rem; text-align:left;">üè† Home</button>
                    <button class="btn btn-info spotify-tab-btn" data-tab="playlists" style="width:100%;margin-bottom:0.5rem; text-align:left;">üìö Browse Playlists</button>
                    <button class="btn btn-info spotify-tab-btn" data-tab="study" style="width:100%;margin-bottom:0.5rem; text-align:left;">üìä Study Stats</button>
                    <button class="btn btn-info spotify-tab-btn" data-tab="recommendations" style="width:100%;margin-bottom:0.5rem; text-align:left;">üéØ Study Recommendations</button>
                    <button class="btn btn-info spotify-tab-btn" data-tab="search" style="width:100%;margin-bottom:0.5rem; text-align:left;">üîç Search Music</button>
                </div>
                
                <!-- Main Area -->
                <div style="flex:1; display:flex; flex-direction:column; min-width:0; overflow:hidden;">
                    <div id="spotify-main" style="flex:1; overflow-y:auto; overflow-x:hidden; padding:1.5rem; box-sizing:border-box;"></div>
                    
                    <!-- Player Bar -->
                    <div id="spotify-player-bar" style="display:flex;align-items:center;padding:1rem;background:#111c2b;border-top:2px solid #222;">
                        <img id="spotify-player-albumart" src="" style="height:50px;width:50px;border-radius:6px;margin-right:1rem;display:none;">
                        <div style="flex:1;">
                            <div id="spotify-player-trackinfo" style="font-weight:bold;"></div>
                            <div id="spotify-player-artistinfo" style="font-size:0.95em;opacity:0.7;"></div>
                            <div style="display:flex;align-items:center;margin-top:0.5rem;gap:0.5rem;">
                                <span id="spotify-current-time" style="font-size:0.8rem;opacity:0.7;min-width:35px;">0:00</span>
                                <input type="range" id="spotify-progress-bar" min="0" max="100" value="0" style="flex:1;height:4px;background:#333;border-radius:2px;outline:none;cursor:pointer;" />
                                <span id="spotify-total-time" style="font-size:0.8rem;opacity:0.7;min-width:35px;">0:00</span>
                            </div>
                        </div>
                        <button class="btn btn-primary" id="spotify-prev-btn-app">‚èÆÔ∏è</button>
                        <button class="btn btn-primary" id="spotify-play-btn-app">‚ñ∂Ô∏è</button>
                        <button class="btn btn-primary" id="spotify-pause-btn-app">‚è∏Ô∏è</button>
                        <button class="btn btn-primary" id="spotify-next-btn-app">‚è≠Ô∏è</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="answer-modal" class="modal">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <h3>Answer the Question</h3>
                <button class="btn btn-secondary" onclick="closeAnswerModal()" style="margin-left: auto;">‚úï Close</button>
            </div>
            <div id="modal-question"></div>
            <div class="input-group">
                <label>Your Answer:</label>
                <textarea id="answer-input" rows="4" placeholder="Type your answer here..."></textarea>
            </div>
            <button class="btn btn-primary" onclick="submitAnswer()">Submit Answer</button>
        </div>
    </div>

    <!-- NEW: Hint turn modal -->
    <div id="hint-turn-modal" class="modal">
        <div class="modal-content">
            <h3>Your Turn!</h3>
            <p>It's your turn to give a hint about your player.</p>
            <div class="input-group">
                <label>Your Hint:</label>
                <textarea id="hint-turn-input" rows="4" placeholder="Give a hint about your player..."></textarea>
            </div>
            <button class="btn btn-primary" onclick="submitHintFromModal()">Submit Hint</button>
            <button class="btn btn-secondary" onclick="hideModal('hint-turn-modal')">‚úï Close</button>
        </div>
    </div>

    <!-- UPDATED: Imposter modal with text input instead of dropdown -->
    <div id="imposter-modal" class="modal">
        <div class="modal-content">
            <h3>üé≠ Imposter Reveal!</h3>
            <p id="imposter-modal-text">You're revealing as the imposter. What location do you think it is?</p>
            <div class="input-group">
                <label id="imposter-guess-label">Location Guess:</label>
                <div class="imposter-guess-hint" id="imposter-guess-hint">Start typing to see suggestions...</div>
                <div class="autocomplete-container">
                    <input type="text" id="location-guess-input" placeholder="Type your guess here..." autocomplete="off">
                    <div class="autocomplete-suggestions" id="autocomplete-suggestions"></div>
                </div>
            </div>
            <button class="btn btn-danger" onclick="submitImposterReveal()">Submit Guess</button>
            <button class="btn btn-secondary" onclick="hideModal('imposter-modal')">‚úï Cancel</button>
        </div>
    </div>

    <div id="scoreboard-modal" class="modal">
        <div class="modal-content large">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h3>üèÜ Detailed Scoreboard</h3>
                <button class="btn btn-warning" onclick="hideScoreboard()" style="margin-left: auto;">‚úï Close</button>
            </div>
            
            <div class="scoreboard-tabs">
                <button class="tab-btn active" onclick="switchTab('current')">Current Scores</button>
                <button class="tab-btn" onclick="switchTab('history')">Game History</button>
                <button class="tab-btn" onclick="switchTab('stats')">Detailed Stats</button>
            </div>

            <div id="current-tab" class="tab-content active">
                <div id="detailed-scoreboard"></div>
            </div>

            <div id="history-tab" class="tab-content">
                <div id="game-history-content"></div>
            </div>

            <div id="stats-tab" class="tab-content">
                <div id="detailed-stats-content"></div>
            </div>
        </div>
    </div>

    <div id="custom-locations-modal" class="modal">
        <div class="modal-content">
            <h3>üéØ Custom Locations</h3>
            <p>Enter your custom locations separated by commas. Leave empty to use default locations.</p>
            <div class="bot-warning">
                ‚ö†Ô∏è Setting custom locations will remove all bots from the room
            </div>
            <div class="input-group">
                <label>Custom Locations:</label>
                <textarea id="custom-locations-input" rows="6" placeholder="Space Station, Underwater Lab, Haunted House, Secret Base, etc."></textarea>
            </div>
            <div style="text-align: center;">
                <button class="btn btn-primary" onclick="setCustomLocations()">Set Custom Locations</button>
                <button class="btn btn-warning" onclick="hideCustomLocations()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="round-summary-modal" class="modal">
        <div class="modal-content">
            <h3>üìä Round Summary</h3>
            <div id="round-summary-content"></div>
            <button class="btn btn-primary" onclick="hideRoundSummary()">Continue</button>
        </div>
    </div>

    <!-- NEW: Leave game confirmation modal -->
    <div id="leave-game-modal" class="modal">
        <div class="modal-content">
            <h3>üö™ Leave Game</h3>
            <p>Are you sure you want to leave the game? You won't be able to rejoin.</p>
            <div style="text-align: center; margin-top: 1rem;">
                <button class="btn btn-danger" onclick="confirmLeaveGame()">Leave</button>
                <button class="btn btn-secondary" onclick="hideModal('leave-game-modal')">Return</button>
            </div>
        </div>
    </div>

    <!-- INSERT WORKING SPOTIFY HTML/JS FROM 1.html HERE (login button, open music button, persistent overlay, sidebar, dashboard, playlists, search, player bar, and all event handlers) -->

    <script>
        const socket = io();
        
        // Comprehensive Socket Debugging
        console.log('üîå Socket.io initialized');
        
        // Log all incoming events
        const originalEmit = socket.emit;
        socket.emit = function(...args) {
            console.log('üì§ EMIT:', args[0], args.slice(1));
            return originalEmit.apply(this, args);
        };
        
        // Log all socket events
        socket.onAny((eventName, ...args) => {
            console.log('üì• RECEIVED:', eventName, args);
        });
        
        socket.on('connect', () => {
            console.log('üîå Socket connected:', socket.id);
        });
        
        socket.on('disconnect', (reason) => {
            console.log('üîå Socket disconnected:', reason);
        });
        
        socket.on('connect_error', (error) => {
            console.log('üîå Socket connection error:', error);
        });
        
        let gameState = {};
        let currentRoom = '';
        let isHost = false;
        let playerName = '';
        let actualPlayerName = '';
        let isReady = false;
        let scoreboardData = [];
        let gameHistory = [];
        let roundEndScoreboard = null;
        let hasClickedReadyToVote = false;
        let customLocations = [];
        let isRoomLocked = false;
        let botCount = 0;
        let usingCustomLocations = false;
        let currentGameType = ''; // NEW: Track current game type
        let currentRoomType = 'public'; // NEW: Track current room type
        let publicLobbies = []; // NEW: Store public lobbies data

        // NEW: Autocomplete variables
        let currentSuggestions = [];
        let selectedSuggestionIndex = -1;

        const locations = [
            "Circus", "Amusement Park", "Crashing Airplane", "Titanic",
            "Burning Orphanage", "Dingy Motel Drug Deal", "Prison", "Safari",
            "Zombie Apocalypse", "Organ-Harvesting Hospital", "Nuclear Submarine",
            "Daycare", "Amazon Rainforest", "Concert Hall", "Space Station",
            "High School", "Haunted Mansion", "Beach"
        ];

        // NEW: Player lists for new games
        const nbaPlayers = ["Lebron James", "Kawhi Leonard", "Steph Curry", "Klay Thompson", "Damian Lillard", "Giannis Antetokounmpo", 
            "Chris Paul", "Zion Williamson", "Ja Morant", "Scottie Barnes", "Chet Holmgren", "Paolo Banchero", 
            "Franz Wagner", "Gradey Dick", "Kyle Lowry", "DeMar DeRozan", "CJ McCollum", "Anthony Davis", 
            "Fred VanVleet", "Miles Bridges", "James Harden", "Russell Westbrook", "Joel Embiid", "Tyrese Maxey", 
            "Mikal Bridges", "Jalen Brunson", "Julius Randle", "OG Anunoby", "Mitchell Robinson", "Kelly Oubre Jr.", 
            "Donte DiVincenzo", "Josh Hart", "Immanuel Quickley", "RJ Barrett", "Jakob Poeltl", "Cam Thomas", 
            "Ben Simmons", "Nic Claxton", "Spencer Dinwiddie", "Jayson Tatum", "Jaylen Brown", "Derrick White", 
            "Jrue Holiday", "Kristaps Porzingis", "Al Horford", "Gary Trent Jr.", "Brook Lopez", "Khris Middleton", 
            "Bobby Portis", "Tyrese Haliburton", "Pascal Siakam", "Myles Turner", "Bennedict Mathurin", "Obi Toppin", 
            "Darius Garland", "Donovan Mitchell", "Evan Mobley", "Jarrett Allen", "DeMar DeRozan", "Zach LaVine", 
            "Nikola Vucevic", "Josh Giddey", "Cade Cunningham", "Jaden Ivey", "Ausar Thompson", "Jalen Duren", 
            "Tobias Harris", "Jimmy Butler", "Bam Adebayo", "Terry Rozier", "Tyler Herro", "Duncan Robinson", 
            "Trae Young", "Clint Capela", "Zaccharie Risacher", "LaMelo Ball", "Miles Bridges", "Brandon Miller", 
            "Grant Williams", "Seth Curry", "Kyle Kuzma", "Jordan Poole", "Alex Sarr", "Shai Gilgeous-Alexander", 
            "Jalen Williams", "Lu Dort", "Alex Caruso", "Nikola Jokic", "Jamal Murray", "Michael Porter Jr.", 
            "Aaron Gordon", "Bruce Brown", "Anthony Edwards", "Mike Conley", "Rudy Gobert", "Karl-Anthony Towns", 
            "Jaden McDaniels", "Naz Reid", "Norman Powell", "Luka Doncic", "Kyrie Irving", "Daniel Gafford", 
            "Kevin Durant", "Devin Booker", "Bradley Beal", "Jusuf Nurkic", "Brandon Ingram", "Dejounte Murray", 
            "Herbert Jones", "D'Angelo Russell", "Austin Reaves", "De'Aaron Fox", "Domantas Sabonis", 
            "Malik Monk", "Buddy Hield", "Andrew Wiggins", "Draymond Green", "Jonathan Kuminga", 
            "Alperen Sengun", "Jalen Green", "Amen Thompson", "Dillon Brooks", "Collin Sexton", "Isaiah Stewart", 
            "Lauri Markkanen", "Walker Kessler", "Jordan Clarkson", "Jaren Jackson Jr.", "Desmond Bane", 
            "Marcus Smart", "Zach Edey", "Victor Wembanyama", "Keldon Johnson", "Devin Vassell", "Jeremy Sochan", 
            "Anfernee Simons", "Scoot Henderson", "Deandre Ayton", "Jerami Grant", "Shaedon Sharpe", 
            "Deni Avdija", "Cooper Flagg"];

        const rappers = ["Drake", "Future", "21 Savage", "Travis Scott", "Kanye", "XXXTentacion", "Nav", "Roddy Ricch", "A Boogie wit da Hoodie", 
            "Post Malone", "Lil Baby", "Lil Wayne", "Baby Keem", "Kendrick Lamar", "Lil Tecca", "Don Toliver", "Chris Brown", 
            "Coi Leray", "Nicki Minaj", "Cardi B", "DaBaby", "J. Cole", "Eminem", "Gunna", "Quavo", "Jay-Z", "Juice WRLD", "Big Black Banana Man", 
            "The Weeknd", "Kid Cudi", "Kodak Black", "Lil Durk", "Lil Skies", "Lil Tjay", "Lil Uzi Vert", "Meek Mill", "Nas", "PARTYNEXTDOOR",
            "Offset", "PARTYNEXTDOOR", "Playboi Carti", "Polo G", "Pop Smoke", "Swae Lee", "Tory Lanez", "Young Thug", "Ty Dolla $ign", "Nicki Minaj"];

        // NEW: Game selection function
        function selectGame(gameType) {
            console.log('üéÆ selectGame called with:', gameType);
            console.log('üéÆ Previous currentGameType:', currentGameType);
            console.log('üéÆ Current room before selection:', currentRoom);
            
            const globalName = document.getElementById('global-player-name').value.trim();
            const nameError = document.getElementById('name-error');
            if (!globalName) {
                if (nameError) {
                    nameError.textContent = 'Please enter your name first';
                    nameError.style.display = 'block';
                }
                showError('Please enter your name before selecting a game.');
                return;
            } else if (nameError) {
                nameError.textContent = '';
                nameError.style.display = 'none';
            }
            currentGameType = gameType;
            console.log('üéÆ New currentGameType set to:', currentGameType);
            document.getElementById('player-name').value = globalName;
            
            // Update UI based on game type
            if (gameType === 'mole') {
                document.getElementById('game-title').textContent = 'üïµÔ∏è The Mole';
                document.getElementById('game-description').textContent = 'Find the imposter among your friends in this exciting deduction game.';
            } else if (gameType === 'nba') {
                document.getElementById('game-title').textContent = 'üèÄ NBA Imposter';
                document.getElementById('game-description').textContent = 'Give hints about NBA players and find the imposter!';
            } else if (gameType === 'rapper') {
                document.getElementById('game-title').textContent = 'üé§ Rapper Imposter';
                document.getElementById('game-description').textContent = 'Give hints about rappers and find the imposter!';
            }

            console.log('üéÆ About to show home screen for gameType:', currentGameType);
            showScreen('home-screen');
            console.log('üéÆ Switched to home screen, game selected:', currentGameType);
        }

        function backToGameSelection() {
            console.log('üîô backToGameSelection called');
            console.log('üîô Previous state - currentGameType:', currentGameType, 'currentRoom:', currentRoom, 'isHost:', isHost);
            
            // Try to properly leave the current room before switching
            if (currentRoom) {
                console.log('üîô Leaving current room:', currentRoom);
                socket.emit('leave_room');
            }
            
            currentGameType = '';
            currentRoom = '';
            isHost = false;
            
            console.log('üîô State cleared - currentGameType:', currentGameType, 'currentRoom:', currentRoom, 'isHost:', isHost);
            playerName = '';
            actualPlayerName = '';
            isReady = false;
            hasClickedReadyToVote = false;
            botCount = 0; // Reset bot count when leaving room
            
            // Reset global name from current name
            const currentName = document.getElementById('player-name').value;
            if (currentName) {
                document.getElementById('global-player-name').value = currentName;
            }
            
            showScreen('game-selection-screen');
        }

        function populateLocationsList(items) {
            const locationsList = document.getElementById('locations-list');
            locationsList.innerHTML = '';
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'location-item';
                div.textContent = item;
                locationsList.appendChild(div);
            });
        }

        // NEW: Autocomplete functionality for imposter guess
        function initializeAutocomplete() {
            const input = document.getElementById('location-guess-input');
            const suggestionsContainer = document.getElementById('autocomplete-suggestions');
            
            input.addEventListener('input', function() {
                const query = this.value.trim().toLowerCase();
                
                if (query.length === 0) {
                    hideSuggestions();
                    return;
                }
                
                let itemsToSearch = locations;
                if (currentGameType === 'nba') {
                    itemsToSearch = nbaPlayers;
                } else if (currentGameType === 'rapper') {
                    itemsToSearch = rappers;
                } else if (customLocations.length > 0) {
                    itemsToSearch = customLocations;
                }
                
                const matches = itemsToSearch.filter(item => 
                    item.toLowerCase().includes(query)
                ).slice(0, 10); // Limit to 10 suggestions
                
                showSuggestions(matches);
            });
            
            input.addEventListener('keydown', function(e) {
                const suggestionsContainer = document.getElementById('autocomplete-suggestions');
                const suggestions = suggestionsContainer.querySelectorAll('.autocomplete-suggestion');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestions.length - 1);
                    updateSelectedSuggestion();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                    updateSelectedSuggestion();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedSuggestionIndex >= 0 && suggestions[selectedSuggestionIndex]) {
                        selectSuggestion(suggestions[selectedSuggestionIndex].textContent);
                    } else {
                        submitImposterReveal();
                    }
                } else if (e.key === 'Escape') {
                    hideSuggestions();
                }
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.autocomplete-container')) {
                    hideSuggestions();
                }
            });
        }
        
        function showSuggestions(matches) {
            const suggestionsContainer = document.getElementById('autocomplete-suggestions');
            currentSuggestions = matches;
            selectedSuggestionIndex = -1;
            
            if (matches.length === 0) {
                hideSuggestions();
                return;
            }
            
            suggestionsContainer.innerHTML = '';
            matches.forEach((match, index) => {
                const div = document.createElement('div');
                div.className = 'autocomplete-suggestion';
                div.textContent = match;
                div.addEventListener('click', () => selectSuggestion(match));
                suggestionsContainer.appendChild(div);
            });
            
            suggestionsContainer.style.display = 'block';
        }
        
        function hideSuggestions() {
            const suggestionsContainer = document.getElementById('autocomplete-suggestions');
            suggestionsContainer.style.display = 'none';
            selectedSuggestionIndex = -1;
        }
        
        function updateSelectedSuggestion() {
            const suggestions = document.querySelectorAll('.autocomplete-suggestion');
            suggestions.forEach((suggestion, index) => {
                suggestion.classList.toggle('selected', index === selectedSuggestionIndex);
            });
        }
        
        function selectSuggestion(value) {
            const input = document.getElementById('location-guess-input');
            input.value = value;
            hideSuggestions();
            input.focus();
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeAutocomplete();
        });

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            
            // Update Spotify buttons when switching screens
                updateSpotifyButtonsOnAllScreens();
            setupSpotifyOpenMusicButton();
            // Call again after a short delay to catch late-rendered buttons
            setTimeout(() => {
                setupSpotifyOpenMusicButton();
            }, 300);
        }

        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('active');
                modal.style.display = 'flex';
                // Defensive: scroll into view in case of overflow
                setTimeout(() => { modal.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 10);
            } else {
                console.error('Modal not found:', modalId);
            }
        }

        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('active');
                modal.style.display = 'none';
                
                // Clear Spotify dashboard updates when closing Spotify modal
                if (modalId === 'spotify-popup' && spotifyDashboardUpdateInterval) {
                    clearInterval(spotifyDashboardUpdateInterval);
                    spotifyDashboardUpdateInterval = null;
                    console.log('üéµ Stopped periodic updates when closing Spotify modal');
                }
            }
        }

        function createRoom() {
            console.log('üèóÔ∏è createRoom called');
            console.log('üèóÔ∏è Current gameType:', currentGameType);
            playerName = document.getElementById('player-name').value.trim();
            if (!playerName) {
                showError('Please enter your name');
                return;
            }
            console.log('üèóÔ∏è Creating room with playerName:', playerName, 'gameType:', currentGameType);
            socket.emit('create_room', { playerName, gameType: currentGameType });
        }

        function showJoinRoom() {
            document.getElementById('join-room-section').style.display = 'block';
            socket.emit('get_public_lobbies', { gameType: currentGameType });
        }

        function joinPublicLobby(roomCode) {
            const playerName = document.getElementById('player-name').value.trim();
            if (!playerName) {
                showError('Please enter your name first');
                return;
            }
            
            document.getElementById('room-code').value = roomCode;
            joinRoom();
        }

        function joinRoom() {
            playerName = document.getElementById('player-name').value.trim();
            const roomCode = document.getElementById('room-code').value.trim().toUpperCase();
            
            if (!playerName || !roomCode) {
                showError('Please enter your name and room code');
                return;
            }
            
            socket.emit('join_room', { roomCode, playerName, gameType: currentGameType });
        }

        function toggleReady() {
            socket.emit('toggle_ready');
        }

        function kickPlayer(targetId) {
            if (!isHost) return;
            
            if (confirm('Are you sure you want to kick this player?')) {
                socket.emit('kick_player', { targetId });
            }
        }

        // Bot management functions (only for The Mole)
        function addBot() {
            console.log('ü§ñ AddBot function called');
            
            if (!isHost) {
                showError('Only the host can add bots');
                return;
            }
            
            const totalPlayers = document.querySelectorAll('.player-card').length;
            
            if (totalPlayers >= 8) {
                showError('Room is full (8/8 players)');
                return;
            }
            
            if (usingCustomLocations) {
                showError('Cannot add bots when using custom locations');
                return;
            }
            
            console.log('ü§ñ Adding bot to room:', currentRoom);
            
            // Now that we know it works, just send one clean request
            setTimeout(() => {
                console.log('ü§ñ Attempting single bot addition');
            socket.emit('add_bot', { difficulty: 'medium' });
                console.log('ü§ñ Single add_bot event emitted');
            }, 500);
        }

        function removeBot(botId) {
            if (!isHost) return;
            
            if (confirm('Are you sure you want to remove this bot?')) {
                socket.emit('remove_bot', { botId });
            }
        }

        function removeAllBots() {
            if (!isHost) return;
            
            if (confirm('Are you sure you want to remove all bots?')) {
                const players = document.querySelectorAll('.player-card.bot');
                players.forEach(playerCard => {
                    const kickBtn = playerCard.querySelector('.kick-btn');
                    if (kickBtn) {
                        kickBtn.click();
                    }
                });
            }
        }

        function updateBotControls() {
            console.log('ü§ñ updateBotControls called');
            console.log('ü§ñ currentGameType:', currentGameType);
            console.log('ü§ñ isHost:', isHost);
            console.log('ü§ñ currentRoom:', currentRoom);
            console.log('ü§ñ botCount:', botCount);
            
            const botControls = document.getElementById('bot-controls');
            console.log('ü§ñ botControls element:', botControls);
            
            // Only show bot controls for The Mole game
            if (currentGameType !== 'mole' || !isHost) {
                console.log('ü§ñ Hiding bot controls - not mole game or not host');
                if (botControls) botControls.style.display = 'none';
                return;
            }
            
            // Safety check: reset bot count if no active room
            if (!currentRoom) {
                console.log('ü§ñ No active room, resetting bot count');
                console.log('ü§ñ currentRoom is:', currentRoom, 'type:', typeof currentRoom);
                botCount = 0;
            } else {
                console.log('ü§ñ Active room found:', currentRoom);
            }
            
            const botCountSpan = document.getElementById('bot-count');
            const addBotBtn = document.getElementById('add-bot-btn');
            const removeAllBotsBtn = document.getElementById('remove-all-bots-btn');
            const botWarning = document.getElementById('bot-warning');
            
            console.log('ü§ñ Bot control elements:', {
                botCountSpan, addBotBtn, removeAllBotsBtn, botWarning
            });
            
            if (botControls) botControls.style.display = 'block';
            if (botCountSpan) botCountSpan.textContent = botCount;
            
            const totalPlayers = document.querySelectorAll('.player-card').length;
            console.log('ü§ñ Total players in updateBotControls:', totalPlayers);
            
            const canAddBot = totalPlayers < 8 && !usingCustomLocations;
            console.log('ü§ñ canAddBot:', canAddBot);
            
            if (addBotBtn) {
            addBotBtn.style.display = 'inline-block';
            addBotBtn.disabled = !canAddBot;
            }
            
            if (totalPlayers >= 8) {
                addBotBtn.textContent = 'ü§ñ Room Full (8/8)';
            } else if (usingCustomLocations) {
                addBotBtn.textContent = 'ü§ñ Disabled (Custom Locations)';
            } else {
                addBotBtn.textContent = `ü§ñ Add Bot (${totalPlayers}/8)`;
            }
            
            removeAllBotsBtn.style.display = botCount > 0 ? 'inline-block' : 'none';
            botWarning.style.display = usingCustomLocations ? 'block' : 'none';
        }

        function startGame() {
            if (!isHost) return;
            
            if (customLocations.length > 0) {
                socket.emit('start_game', { customLocations, gameType: currentGameType });
            } else {
                socket.emit('start_game', { gameType: currentGameType });
            }
        }

        // NEW: Hint functions for NBA/Rapper games
        function giveHint() {
            const hint = document.getElementById('hint-input').value.trim();
            if (!hint) {
                showError('Please provide a hint');
                return;
            }

            socket.emit('give_hint', { hint });
            document.getElementById('hint-input').value = '';
            document.getElementById('give-hint-section').style.display = 'none';
        }

        function submitHintFromModal() {
            const hint = document.getElementById('hint-turn-input').value.trim();
            if (!hint) {
                showError('Please provide a hint');
                return;
            }

            socket.emit('give_hint', { hint });
            document.getElementById('hint-turn-input').value = '';
            hideModal('hint-turn-modal');
        }

        function showImposterGuess() {
            // Update modal text based on game type
            const modalText = document.getElementById('imposter-modal-text');
            const guessLabel = document.getElementById('imposter-guess-label');
            const guessHint = document.getElementById('imposter-guess-hint');
            const input = document.getElementById('location-guess-input');
            
            if (currentGameType === 'nba') {
                modalText.textContent = "You're revealing as the imposter. Which NBA player do you think it is?";
                guessLabel.textContent = 'NBA Player Guess:';
                guessHint.textContent = 'Start typing an NBA player name...';
                input.placeholder = 'Type NBA player name...';
            } else if (currentGameType === 'rapper') {
                modalText.textContent = "You're revealing as the imposter. Which rapper do you think it is?";
                guessLabel.textContent = 'Rapper Guess:';
                guessHint.textContent = 'Start typing a rapper name...';
                input.placeholder = 'Type rapper name...';
            } else {
                modalText.textContent = "You're revealing as the imposter. What location do you think it is?";
                guessLabel.textContent = 'Location Guess:';
                guessHint.textContent = 'Start typing a location...';
                input.placeholder = 'Type location name...';
            }
            
            // Clear the input
            input.value = '';
            hideSuggestions();
            
            showModal('imposter-modal');
            
            // Focus the input after modal is shown
            setTimeout(() => {
                input.focus();
            }, 100);
        }

        // The Mole functions (unchanged)
        function askQuestion() {
            const targetId = document.getElementById('target-select').value;
            if (!targetId) {
                showError('Please select a player to ask');
                return;
            }

            updateQuestionStatus('asking', 'Sending question...');
            socket.emit('ask_question', { targetId });
        }

        function submitAnswer() {
            const answer = document.getElementById('answer-input').value.trim();
            if (!answer) {
                showError('Please provide an answer');
                return;
            }

            const { asker, target, question } = gameState.currentQuestion;
            socket.emit('submit_answer', { asker, target, question, answer });
            
            document.getElementById('answer-input').value = '';
            hideModal('answer-modal');
        }

        // New function to close answer modal and show question on screen
        function closeAnswerModal() {
            hideModal('answer-modal');
            showAnswerOnScreen();
        }

        // Show answer input section on the main screen
        function showAnswerOnScreen() {
            if (!gameState.currentQuestion) return;
            
            const { asker, question } = gameState.currentQuestion;
            document.getElementById('answer-question-label').textContent = `${asker} asks:`;
            document.getElementById('answer-question-text').textContent = question;
            document.getElementById('answer-input-section').style.display = 'block';
            document.getElementById('answer-input-screen').focus();
        }

        // Submit answer from the screen input
        function submitAnswerFromScreen() {
            const answer = document.getElementById('answer-input-screen').value.trim();
            if (!answer) {
                showError('Please provide an answer');
                return;
            }

            const { asker, target, question } = gameState.currentQuestion;
            socket.emit('submit_answer', { asker, target, question, answer });
            
            document.getElementById('answer-input-screen').value = '';
            document.getElementById('answer-input-section').style.display = 'none';
        }

        // Cancel answering from screen
        function cancelAnswerFromScreen() {
            document.getElementById('answer-input-screen').value = '';
            document.getElementById('answer-input-section').style.display = 'none';
        }

        // Add entry to the answer log
        function addToLog(message, type = 'info') {
            const logContainer = document.getElementById('answer-log');
            const noQuestionsDiv = document.getElementById('no-questions-yet');
            
            // Hide the "no questions yet" message
            if (noQuestionsDiv) {
                noQuestionsDiv.style.display = 'none';
            }
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.style.cssText = `
                margin-bottom: 1rem;
                padding: 0.75rem;
                border-radius: 8px;
                border-left: 4px solid ${type === 'question' ? '#3498db' : type === 'answer' ? '#27ae60' : '#95a5a6'};
                background: rgba(255,255,255,0.05);
            `;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.innerHTML = `
                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.25rem;">
                    ${timestamp}
                </div>
                <div>${message}</div>
            `;
            
            logContainer.appendChild(logEntry);
            
            // Auto-scroll to bottom of log
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function readyToVote() {
            if (hasClickedReadyToVote) {
                showError('You have already indicated you are ready to vote');
                return;
            }
            
            socket.emit('ready_to_vote');
            hasClickedReadyToVote = true;
            
            const btn = document.getElementById('ready-to-vote-btn');
            btn.textContent = 'Ready! Waiting for others...';
            btn.disabled = true;
            btn.className = 'btn btn-primary';
        }

        function submitVote(targetId) {
            console.log('Submitting vote for:', targetId);
            socket.emit('submit_vote', { targetId });
            document.getElementById('voting-section').style.display = 'none';
        }

        function showImposterReveal() {
            showImposterGuess(); // Use the same modal
        }

        function submitImposterReveal() {
            const locationGuess = document.getElementById('location-guess-input').value.trim();
            if (!locationGuess) {
                const itemType = currentGameType === 'nba' ? 'player' : 
                                currentGameType === 'rapper' ? 'rapper' : 'location';
                showError(`Please enter a ${itemType}`);
                return;
            }
            
            if (currentGameType === 'mole') {
                socket.emit('imposter_reveal', { locationGuess });
            } else {
                socket.emit('imposter_guess', { guess: locationGuess });
            }
            hideModal('imposter-modal');
        }

        function updateGameLocations() {
            const gameLocationsList = document.getElementById('game-locations-list');
            const gameItemsTitle = document.getElementById('game-items-title');
            
            gameLocationsList.innerHTML = '';
            
            let itemsToShow = locations;
            let titleText = 'üìç Possible Locations';
            
            if (currentGameType === 'nba') {
                itemsToShow = nbaPlayers;
                titleText = 'üèÄ NBA Players';
            } else if (currentGameType === 'rapper') {
                itemsToShow = rappers;
                titleText = 'üé§ Rappers';
            } else if (customLocations.length > 0) {
                itemsToShow = customLocations;
            }
            
            gameItemsTitle.textContent = titleText;
            
            itemsToShow.forEach(item => {
                const div = document.createElement('div');
                div.className = 'location-item';
                div.textContent = item;
                gameLocationsList.appendChild(div);
            });
        }

        function backToLobby() {
            showScreen('lobby-screen');
            gameState = {};
            hasClickedReadyToVote = false;
            setTimeout(() => {
                socket.emit('request_scoreboard');
            }, 500);
        }

        function updateQuestionStatus(status, message) {
            const statusElement = document.getElementById('question-status');
            const askBtn = document.getElementById('ask-question-btn');
            
            if (statusElement) {
                statusElement.style.display = 'block';
                statusElement.className = `question-status-${status}`;
                statusElement.textContent = message;
            }
            
            if (askBtn) {
                switch(status) {
                    case 'ready':
                        askBtn.disabled = false;
                        askBtn.textContent = 'üé≤ Ask Question';
                        break;
                    case 'asking':
                        askBtn.disabled = true;
                        askBtn.textContent = 'Asking...';
                        break;
                    case 'waiting':
                        askBtn.disabled = true;
                        askBtn.textContent = 'Waiting for answer...';
                        break;
                    case 'asked':
                        askBtn.disabled = true;
                        askBtn.textContent = 'Question asked this turn';
                        break;
                }
            }
        }

        function showScoreboard() {
            socket.emit('request_scoreboard');
            showModal('scoreboard-modal');
        }

        function hideScoreboard() {
            hideModal('scoreboard-modal');
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.tab-btn:nth-child(${tabName === 'current' ? 1 : tabName === 'history' ? 2 : 3})`).classList.add('active');
            
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        function showRoundSummary(summaryData) {
            document.getElementById('round-summary-content').innerHTML = summaryData;
            showModal('round-summary-modal');
        }

        function hideRoundSummary() {
            hideModal('round-summary-modal');
        }

        function showCustomLocations() {
            showModal('custom-locations-modal');
        }

        function hideCustomLocations() {
            hideModal('custom-locations-modal');
        }

        function setCustomLocations() {
            const input = document.getElementById('custom-locations-input').value.trim();
            
            if (input) {
                customLocations = input.split(',')
                    .map(loc => loc.trim())
                    .filter(loc => loc.length > 0);
                
                if (customLocations.length < 3) {
                    showError('Please provide at least 3 custom locations');
                    return;
                }
                
                showSuccess(`Custom locations set: ${customLocations.length} locations`);
            } else {
                customLocations = [];
                showSuccess('Using default locations');
            }
            
            hideCustomLocations();
        }

        function changeRoomType(roomType) {
            if (!isHost) {
                showError('Only the host can change room type');
                return;
            }
            
            socket.emit('change_room_type', { roomType });
        }

        function updateRoomTypeDisplay(roomType) {
            currentRoomType = roomType;
            const roomTypeDisplay = document.getElementById('room-type-display');
            const roomTypeControls = document.getElementById('room-type-controls');
            
            // Update room type display
            roomTypeDisplay.className = `room-type-status ${roomType}`;
            
            const typeTexts = {
                public: 'üåê Public',
                private: 'üîí Private', 
                locked: 'üö´ Locked'
            };
            
            roomTypeDisplay.textContent = typeTexts[roomType];
            
            // Update room type controls (host only)
            if (isHost) {
                roomTypeControls.style.display = 'block';
                
                // Update active button
                document.querySelectorAll('.room-type-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-type="${roomType}"]`).classList.add('active');
                
                // Update description
                const descriptions = {
                    public: 'Public rooms are visible in the lobby browser and joinable by code.',
                    private: 'Private rooms are only joinable by code (not visible in lobby browser).',
                    locked: 'Locked rooms - no new players can join.'
                };
                document.getElementById('room-type-description').textContent = descriptions[roomType];
            } else {
                roomTypeControls.style.display = 'none';
            }
        }

        function displayPublicLobbies(lobbies) {
            console.log('Displaying public lobbies:', lobbies);
            const container = document.getElementById('public-lobbies-list');
            
            if (!lobbies || lobbies.length === 0) {
                container.innerHTML = '<p>No public lobbies available at the moment.</p>';
                return;
            }
            
            let html = '';
            lobbies.forEach(lobby => {
                const gameTypeText = lobby.gameType === 'nba' ? 'NBA Imposter' : 
                                    lobby.gameType === 'rapper' ? 'Rapper Imposter' : 'The Mole';
                
                const timeAgo = getTimeAgo(new Date(lobby.createdAt));
                
                html += `
                    <div class="public-lobby-item" onclick="joinPublicLobby('${lobby.roomCode}')">
                        <div class="public-lobby-header">
                            <span class="public-lobby-code">${lobby.roomCode}</span>
                            <span class="public-lobby-game-type">${gameTypeText}</span>
                        </div>
                        <div class="public-lobby-details">
                            <div class="public-lobby-detail players">
                                üë• ${lobby.playerCount}/${lobby.maxPlayers} players
                            </div>
                            <div class="public-lobby-detail">
                                üëë ${lobby.hostName}
                            </div>
                            ${lobby.botCount > 0 ? `<div class="public-lobby-detail bots">ü§ñ ${lobby.botCount} bots</div>` : ''}
                            ${lobby.usingCustomLocations ? '<div class="public-lobby-detail custom">üéØ Custom locations</div>' : ''}
                            <div class="public-lobby-detail time">
                                ‚è∞ ${timeAgo}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            return `${Math.floor(diffHours / 24)}d ago`;
        }

        // Socket event handlers
        socket.on('room_created', (data) => {
            console.log('üè† ROOM_CREATED event received:', data);
            console.log('üè† Previous room:', currentRoom, 'New room:', data.roomCode);
            console.log('üè† Previous gameType:', currentGameType, 'Room gameType:', data.gameType);
            leftRoom = false;
            currentRoom = data.roomCode;
            isHost = data.isHost;
            actualPlayerName = data.actualName;
            playerName = actualPlayerName;
            console.log('üè† Room state updated - currentRoom:', currentRoom, 'isHost:', isHost);
            currentGameType = data.gameType;
            currentRoomType = data.roomType || 'public';
            document.getElementById('room-display').textContent = currentRoom;
            updateRoomTypeDisplay(currentRoomType);
            showScreen('lobby-screen');
            showSuccess(`Room created! Code: ${currentRoom}`);
        });

        socket.on('room_joined', (data) => {
            console.log('üè† ROOM_JOINED event received:', data);
            console.log('üè† Previous room:', currentRoom, 'Joined room:', data.roomCode);
            console.log('üè† Previous gameType:', currentGameType, 'Room gameType:', data.gameType);
            leftRoom = false;
            currentRoom = data.roomCode;
            isHost = data.isHost;
            actualPlayerName = data.actualName;
            playerName = actualPlayerName;
            console.log('üè† Room state updated - currentRoom:', currentRoom, 'isHost:', isHost);
            currentGameType = data.gameType;
            currentRoomType = data.roomType || 'public';
            document.getElementById('room-display').textContent = currentRoom;
            updateRoomTypeDisplay(currentRoomType);
            showScreen('lobby-screen');
            showSuccess(`Joined room: ${currentRoom}`);
        });

        socket.on('name_changed', (data) => {
            showWarning(`Your name was changed from "${data.originalName}" to "${data.newName}" because that name was already taken.`);
        });

        socket.on('room_type_changed', (data) => {
            updateRoomTypeDisplay(data.roomType);
            showInfo(data.message);
        });

        socket.on('public_lobbies', (data) => {
            console.log('Received public lobbies:', data);
            publicLobbies = data;
            displayPublicLobbies(data);
        });

        socket.on('kicked', (data) => {
            showError(data.message);
            backToGameSelection();
        });

        // Bot event handlers (The Mole only)
        socket.on('bot_added', (data) => {
            console.log('ü§ñ bot_added event received:', data);
            
            // Clear the timeout since we got a response
            if (window.lastBotAddTimeout) {
                clearTimeout(window.lastBotAddTimeout);
                window.lastBotAddTimeout = null;
            }
            
            showSuccess(`Bot ${data.botName} added to the room`);
            botCount = data.botCount;
            console.log('ü§ñ New bot count:', botCount);
            updateBotControls();
            console.log('ü§ñ Bot controls updated');
        });

        socket.on('bot_removed', (data) => {
            showInfo(`Bot ${data.botName} removed from the room`);
            botCount = data.botCount;
            updateBotControls();
        });

        socket.on('bots_removed_custom_locations', (data) => {
            showWarning(`${data.removedBots.length} bots removed: ${data.removedBots.join(', ')}`);
            showInfo(data.message);
            botCount = 0;
            updateBotControls();
        });

        socket.on('bot_error', (data) => {
            console.log('ü§ñ bot_error event received:', data);
            
            // Clear the timeout since we got a response (even if error)
            if (window.lastBotAddTimeout) {
                clearTimeout(window.lastBotAddTimeout);
                window.lastBotAddTimeout = null;
            }
            
            showError(`Bot error: ${data.message || 'Unknown error'}`);
        });

        socket.on('room_info', (data) => {
            console.log('üè† ROOM_INFO received from server:', data);
            console.log('üè† Server thinks room gameType is:', data.gameType);
            console.log('üè† Client thinks room gameType is:', currentGameType);
            console.log('üè† Room info match:', data.gameType === currentGameType);
        });

        socket.on('player_kicked', (data) => {
            if (data.wasBot) {
                showInfo(`Bot ${data.kickedPlayerName} was removed`);
                botCount = data.botCount;
            } else {
                showInfo(`${data.kickedPlayerName} was kicked from the room`);
            }
            
            // Check if current player became host
            const currentPlayer = data.players.find(p => p.name === actualPlayerName);
            if (currentPlayer && currentPlayer.isHost && !isHost) {
                isHost = true;
                showInfo('You are now the host!');
            }
            
            updateLobbyPlayers(data.players);
            if (data.scoreboard) {
                updateLobbyScoreboard(data.scoreboard);
            }
            if (data.hasOwnProperty('roomType')) {
                updateRoomTypeDisplay(data.roomType);
            }
            updateBotControls();
        });

        socket.on('room_updated', (data) => {
            // Check if current player became host
            const currentPlayer = data.players.find(p => p.name === actualPlayerName);
            if (currentPlayer && currentPlayer.isHost && !isHost) {
                isHost = true;
                showInfo('You are now the host!');
            }
            
            updateLobbyPlayers(data.players);
            if (data.scoreboard) {
                updateLobbyScoreboard(data.scoreboard);
            }
            if (data.hasOwnProperty('roomType')) {
                updateRoomTypeDisplay(data.roomType);
            }
            if (data.hasOwnProperty('botCount')) {
                botCount = data.botCount;
            }
            if (data.hasOwnProperty('usingCustomLocations')) {
                usingCustomLocations = data.usingCustomLocations;
            }
            if (data.hasOwnProperty('gameType')) {
                currentGameType = data.gameType;
            }
            updateBotControls();
        });

        socket.on('player_left', (data) => {
            showInfo(`${data.playerName} left the room`);
            
            // Check if current player became host
            const currentPlayer = data.players.find(p => p.name === actualPlayerName);
            if (currentPlayer && currentPlayer.isHost && !isHost) {
                isHost = true;
                showInfo('You are now the host!');
            }
            
            updateLobbyPlayers(data.players);
            if (data.scoreboard) {
                updateLobbyScoreboard(data.scoreboard);
            }
            if (data.hasOwnProperty('roomType')) {
                updateRoomTypeDisplay(data.roomType);
            }
            if (data.hasOwnProperty('botCount')) {
                botCount = data.botCount;
            }
            updateBotControls();
        });

        socket.on('game_started', (data) => {
            gameState = data;
            hasClickedReadyToVote = false;
            currentGameType = data.gameType;
            
            // Clear any persistent UI elements
            document.getElementById('ask-section').style.display = 'none';
            document.getElementById('give-hint-section').style.display = 'none';
            document.getElementById('ready-to-vote-section').style.display = 'none';
            document.getElementById('voting-section').style.display = 'none';
            document.getElementById('imposter-reveal-section').style.display = 'none';
            document.getElementById('imposter-guess-section').style.display = 'none';
            document.getElementById('question-status').style.display = 'none';
            
            if (data.scoreboard) {
                scoreboardData = data.scoreboard;
            }
            showScreen('game-screen');
            updateGameDisplay();
            updateGameLocations();
            
            if (data.isImposter) {
                addToLog('üé≠ You are the IMPOSTER!');
            } else {
                if (currentGameType === 'mole') {
                    addToLog(`üìç Location: ${data.playerRole}`);
                } else {
                    addToLog(`üë§ Your ${currentGameType === 'nba' ? 'NBA Player' : 'Rapper'}: ${data.playerRole}`);
                }
            }
        });

        // NEW: Hint given event for NBA/Rapper games
        socket.on('hint_given', (data) => {
            const hintText = `üí° ${data.player}: "${data.hint}"`;
            document.getElementById('current-hint-display').innerHTML = hintText;
            
            gameState.hintsThisRound = data.hintsThisRound;
            gameState.currentTurn = data.currentTurn;
            updateGameDisplay();
        });

        // NEW: Your turn event for hint games
        socket.on('your_hint_turn', () => {
            showModal('hint-turn-modal');
            document.getElementById('hint-turn-input').focus();
        });

        socket.on('question_asked', (data) => {
            gameState.currentQuestion = data;
            gameState.questionAskedThisTurn = true;
            gameState.waitingForAnswer = true;
            
            document.getElementById('current-question').innerHTML = 
                `<strong>${data.asker}</strong> asks <strong>${data.target}</strong>: "${data.question}"`;
            
            // Add to answer log
            addToLog(`<strong>${data.asker}</strong> asks <strong>${data.target}</strong>: "${data.question}"`, 'question');
            
            if (data.targetId === socket.id) {
                document.getElementById('modal-question').innerHTML = 
                    `<strong>${data.asker}</strong> asks: "${data.question}"`;
                showModal('answer-modal');
                document.getElementById('answer-input').focus();
            }
        });

        socket.on('answer_submitted', (data) => {
            // Add answer to log for everyone to see
            if (data && data.target && data.answer) {
                addToLog(`<strong>${data.target}</strong> answers: "${data.answer}"`, 'answer');
            }
            
            if (gameState.currentQuestion && gameState.currentQuestion.asker === playerName) {
                gameState.questionAskedThisTurn = false;
                gameState.waitingForAnswer = false;
                updateQuestionStatus('ready', 'Answer received! You can ask another question if it\'s still your turn.');
            }
            
            // Hide answer input section if it's visible
            document.getElementById('answer-input-section').style.display = 'none';
        });

        socket.on('game_updated', (data) => {
            console.log('Game updated:', data.status, 'Round:', data.currentRound, 'Current turn:', data.currentTurn);
            gameState = { ...gameState, ...data };
            if (data.scoreboard) {
                scoreboardData = data.scoreboard;
            }
            updateGameDisplay();
            
            if (data.status === 'voting') {
                showVotingSection();
            } else if (data.status === 'ended') {
                showGameOver();
            }
        });

        socket.on('vote_submitted', (data) => {
            if (data.votesReceived === data.totalPlayers) {
                roundEndScoreboard = {
                    round: gameState.currentRound,
                    scoreboard: [...scoreboardData]
                };
            }
        });

        socket.on('ready_count_updated', (data) => {
            if (gameState.status === 'playing') {
                gameState.readyToVoteCount = data.readyCount;
                updateGameDisplay();
            }
        });

        socket.on('all_votes_received', () => {
            // This event is no longer needed as we handle round end in game_updated
        });

        socket.on('game_over', (result) => {
            console.log('Game over event received:', result);
            
            // Clear any persistent UI elements
            document.getElementById('ask-section').style.display = 'none';
            document.getElementById('give-hint-section').style.display = 'none';
            document.getElementById('ready-to-vote-section').style.display = 'none';
            document.getElementById('voting-section').style.display = 'none';
            document.getElementById('imposter-reveal-section').style.display = 'none';
            document.getElementById('imposter-guess-section').style.display = 'none';
            document.getElementById('question-status').style.display = 'none';
            
            if (result.winner === 'imposter_left') {
                showError('Imposter left the game! No one wins.');
            }
        });

        socket.on('scoreboard_updated', (data) => {
            scoreboardData = data.scoreboard || [];
            gameHistory = data.gameHistory || [];
            updateDetailedScoreboard();
        });

        socket.on('error', (message) => {
            console.log('‚ùå Generic error received:', message);
            
            // Handle specific bot-related errors
            if (message.includes('Bots are only available for The Mole game')) {
                console.log('‚ùå SERVER BUG: Server thinks room is not mole game!');
                console.log('‚ùå Client state - gameType:', currentGameType, 'room:', currentRoom, 'isHost:', isHost);
                
                // Clear timeout since we got a response (even if wrong)
                if (window.lastBotAddTimeout) {
                    clearTimeout(window.lastBotAddTimeout);
                    window.lastBotAddTimeout = null;
                }
                
                showError(`Server Error: ${message}\n\nDebug Info:\n- Client gameType: ${currentGameType}\n- Room: ${currentRoom}\n- Is Host: ${isHost}\n\nThis appears to be a server-side validation bug.`);
                return;
            }
            
            showError(message);
        });

        // NEW: Handle reconnection events
        socket.on('reconnected', (data) => {
            leftRoom = false;
            currentRoom = data.roomCode;
            isHost = data.isHost;
            actualPlayerName = data.actualName;
            playerName = actualPlayerName;
            currentGameType = data.gameType;
            currentRoomType = data.roomType || 'public';
            
            // Clear disconnection state
            disconnectedFromRoom = null;
            disconnectTime = null;
            
            document.getElementById('room-display').textContent = currentRoom;
            updateRoomTypeDisplay(currentRoomType);
            
            // Remove reconnection button
            const reconnectBtn = document.getElementById('reconnect-btn');
            if (reconnectBtn) {
                reconnectBtn.style.display = 'none';
            }
            
            // Hide join room section
            document.getElementById('join-room-section').style.display = 'none';
            
            showScreen('lobby-screen');
            showSuccess(`Reconnected to room: ${currentRoom}`);
        });

        socket.on('player_reconnected', (data) => {
            showInfo(`${data.playerName} reconnected to the game!`);
            updateLobbyPlayers(data.players);
            if (data.scoreboard) {
                updateLobbyScoreboard(data.scoreboard);
            }
            if (data.hasOwnProperty('roomType')) {
                updateRoomTypeDisplay(data.roomType);
            }
            if (data.hasOwnProperty('botCount')) {
                botCount = data.botCount;
            }
            updateBotControls();
        });

        // NEW: Handle disconnection tracking
        socket.on('player_left', (data) => {
            showInfo(`${data.playerName} left the room`);
            
            // Check if current player became host
            const currentPlayer = data.players.find(p => p.name === actualPlayerName);
            if (currentPlayer && currentPlayer.isHost && !isHost) {
                isHost = true;
                showInfo('You are now the host!');
            }
            
            updateLobbyPlayers(data.players);
            if (data.scoreboard) {
                updateLobbyScoreboard(data.scoreboard);
            }
            if (data.hasOwnProperty('roomType')) {
                updateRoomTypeDisplay(data.roomType);
            }
            if (data.hasOwnProperty('botCount')) {
                botCount = data.botCount;
            }
            updateBotControls();
            
            // Check if we were disconnected and can reconnect
            if (data.disconnectedPlayers && data.disconnectedPlayers.includes(actualPlayerName)) {
                disconnectedFromRoom = {
                    roomCode: currentRoom,
                    playerName: actualPlayerName
                };
                disconnectTime = Date.now();
                showWarning('You were disconnected! You can reconnect within 60 seconds.');
                
                // Set the room code in the join input for easy reconnection
                document.getElementById('room-code').value = currentRoom;
                
                showScreen('home-screen');
                document.getElementById('join-room-section').style.display = 'block';
                checkForReconnection();
            }
        });

        // NEW: Check for reconnection on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeAutocomplete();
        });

        function updateLobbyPlayers(players) {
            const container = document.getElementById('lobby-players');
            container.innerHTML = '';
            
            players.forEach(player => {
                const div = document.createElement('div');
                div.className = 'player-card';
                if (player.isHost) div.classList.add('host');
                if (player.isReady) div.classList.add('ready');
                if (player.isBot) div.classList.add('bot');
                
                let kickButton = '';
                if (isHost && !player.isHost) {
                    kickButton = `<button class="kick-btn" onclick="${player.isBot ? 'removeBot' : 'kickPlayer'}('${player.id}')" title="${player.isBot ? 'Remove bot' : 'Kick player'}">‚úï</button>`;
                }
                
                let statusText = '';
                if (player.isHost) {
                    statusText = 'üëë Host';
                } else if (player.isBot) {
                    statusText = 'ü§ñ Bot';
                } else {
                    statusText = player.isReady ? '‚úÖ Ready' : '‚è≥ Not Ready';
                }
                
                div.innerHTML = `
                    ${kickButton}
                    <div><strong>${player.name}</strong></div>
                    <div>${statusText}</div>
                `;
                container.appendChild(div);
            });

            const readyBtn = document.getElementById('ready-btn');
            const startBtn = document.getElementById('start-btn');
            const customLocationsBtn = document.getElementById('custom-locations-btn');
            
            if (isHost) {
                const humanPlayers = players.filter(p => !p.isBot);
                const allHumansReady = humanPlayers.filter(p => !p.isHost).every(p => p.isReady);
                const hasEnoughPlayers = players.length >= 3;
                
                startBtn.style.display = (allHumansReady && hasEnoughPlayers) ? 'inline-block' : 'none';
                customLocationsBtn.style.display = currentGameType === 'mole' ? 'inline-block' : 'none';
                readyBtn.style.display = 'none'; // Always hide ready button for host
            } else {
                const currentPlayer = players.find(p => p.name === actualPlayerName);
                readyBtn.textContent = currentPlayer?.isReady ? 'Cancel Ready' : 'Ready Up';
                readyBtn.className = `btn ${currentPlayer?.isReady ? 'btn-warning' : 'btn-primary'}`;
                startBtn.style.display = 'none';
                customLocationsBtn.style.display = 'none';
            }
            
            updateBotControls();
        }

        function updateLobbyScoreboard(scoreboard) {
            const container = document.getElementById('lobby-scoreboard-content');
            
            if (!scoreboard || scoreboard.length === 0) {
                container.innerHTML = '<p>No games played yet. Start your first game!</p>';
                return;
            }

            const topPlayers = scoreboard.slice(0, 5);
            let html = '<div class="scoreboard-table">';
            html += '<table style="width: 100%;">';
            html += '<thead><tr><th>Rank</th><th>Player</th><th>Score</th><th>Games Won</th></tr></thead>';
            html += '<tbody>';
            
            topPlayers.forEach((player, index) => {
                const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
                let playerClass = '';
                if (!player.isOnline) playerClass += 'offline ';
                if (player.isBot) playerClass += 'bot ';
                
                html += `
                    <tr>
                        <td><span class="rank ${rankClass}">#${index + 1}</span></td>
                        <td><span class="player-name ${playerClass}">${player.name}${player.isBot ? ' ü§ñ' : ''}</span></td>
                        <td><span class="score">${player.score}</span></td>
                        <td>${player.gamesWon}/${player.gamesPlayed}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        function updateGameDisplay() {
            if (!gameState.playerOrder) return;

            document.getElementById('current-round').textContent = gameState.currentRound || 1;
            
            // Update question/hint count display based on game type
            if (currentGameType === 'mole') {
                document.getElementById('questions-display').style.display = 'block';
                document.getElementById('hints-display').style.display = 'none';
                document.getElementById('questions-count').textContent = 
                    `${gameState.questionsThisRound || 0}/${gameState.questionsPerRound || 5}`;
            } else {
                document.getElementById('questions-display').style.display = 'none';
                document.getElementById('hints-display').style.display = 'block';
                document.getElementById('hints-count').textContent = 
                    `${gameState.hintsThisRound || 0}/${gameState.hintsPerRound || gameState.playerOrder.length}`;
            }
            
            const currentPlayerIndex = gameState.currentTurn || 0;
            const currentPlayer = gameState.playerOrder[currentPlayerIndex];
            document.getElementById('current-turn').textContent = currentPlayer?.name || '-';

            const roleDisplay = document.getElementById('role-display');
            if (gameState.isImposter) {
                roleDisplay.className = 'role-display role-imposter';
                if (currentGameType === 'mole') {
                    roleDisplay.innerHTML = 'üé≠ You are the IMPOSTER!<br>Find out the location!';
                } else {
                    const itemType = currentGameType === 'nba' ? 'NBA player' : 'rapper';
                    roleDisplay.innerHTML = `üé≠ You are the IMPOSTER!<br>Find out the ${itemType}!`;
                }
                document.getElementById('imposter-reveal-section').style.display = currentGameType === 'mole' ? 'block' : 'none';
                document.getElementById('imposter-guess-section').style.display = currentGameType !== 'mole' ? 'block' : 'none';
            } else if (gameState.playerRole) {
                roleDisplay.className = 'role-display role-location';
                if (currentGameType === 'mole') {
                    roleDisplay.innerHTML = `üìç Location: <strong>${gameState.playerRole}</strong><br>Find the imposter!`;
                } else {
                    const icon = currentGameType === 'nba' ? 'üèÄ' : 'üé§';
                    const itemType = currentGameType === 'nba' ? 'NBA Player' : 'Rapper';
                    roleDisplay.innerHTML = `${icon} Your ${itemType}: <strong>${gameState.playerRole}</strong><br>Find the imposter!`;
                }
                document.getElementById('imposter-reveal-section').style.display = 'none';
                document.getElementById('imposter-guess-section').style.display = 'none';
            }

            const playersContainer = document.getElementById('game-players');
            playersContainer.innerHTML = '';
            
            gameState.playerOrder?.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = 'player-card';
                if (index === gameState.currentTurn) div.classList.add('current-turn');
                if (player.isBot) div.classList.add('bot');
                
                div.innerHTML = `<strong>${player.name}${player.isBot ? ' ü§ñ' : ''}</strong>`;
                playersContainer.appendChild(div);
            });

            // Show/hide appropriate sections based on game type
            const questionSection = document.getElementById('question-section');
            const hintSection = document.getElementById('hint-section');
            const answerLogSection = document.getElementById('answer-log-section');
            
            if (currentGameType === 'mole') {
                questionSection.style.display = 'block';
                hintSection.style.display = 'none';
                if (answerLogSection) answerLogSection.style.display = 'block';
                updateMoleGameSection();
            } else {
                questionSection.style.display = 'none';
                hintSection.style.display = 'block';
                if (answerLogSection) answerLogSection.style.display = 'none';
                updateHintGameSection();
            }

            const readyToVoteSection = document.getElementById('ready-to-vote-section');
            const readyCountDisplay = document.getElementById('ready-count-display');
            const requiredCountSpan = document.getElementById('required-count');
            const readyToVoteBtn = document.getElementById('ready-to-vote-btn');

            const hintsOrQuestions = currentGameType === 'mole' ? 
                gameState.questionsThisRound : gameState.hintsThisRound;
            const hintsOrQuestionsPerRound = currentGameType === 'mole' ? 
                gameState.questionsPerRound : gameState.hintsPerRound;

            if (gameState.status === 'playing' && hintsOrQuestions >= hintsOrQuestionsPerRound) {
                readyToVoteSection.style.display = 'block';
                
                const readyCount = gameState.readyToVoteCount || 0;
                const requiredCount = (gameState.playerOrder?.length || 2) - 1;
                
                readyCountDisplay.textContent = `${readyCount}/${requiredCount} players ready`;
                requiredCountSpan.textContent = requiredCount;
                
                if (hasClickedReadyToVote) {
                    readyToVoteBtn.textContent = 'Ready! Waiting for others...';
                    readyToVoteBtn.disabled = true;
                    readyToVoteBtn.className = 'btn btn-primary';
                } else {
                    readyToVoteBtn.textContent = "I'm Ready to Vote!";
                    readyToVoteBtn.disabled = false;
                    readyToVoteBtn.className = 'btn btn-warning';
                }
            } else {
                readyToVoteSection.style.display = 'none';
            }

            updateGameScoreboard();
        }

        function updateMoleGameSection() {
            const targetSelect = document.getElementById('target-select');
            targetSelect.innerHTML = '<option value="">Select player to ask</option>';
            
            gameState.playerOrder?.forEach(player => {
                if (!player.isYou) {
                    const option = document.createElement('option');
                    option.value = player.id;
                    option.textContent = `${player.name}${player.isBot ? ' ü§ñ' : ''}`;
                    targetSelect.appendChild(option);
                }
            });

            const askSection = document.getElementById('ask-section');
            const isMyTurn = gameState.playerOrder?.[gameState.currentTurn]?.isYou;
            
            askSection.style.display = (isMyTurn && gameState.status === 'playing') ? 'block' : 'none';

            if (isMyTurn && gameState.status === 'playing') {
                if (gameState.waitingForAnswer) {
                    updateQuestionStatus('waiting', 'Waiting for answer to your question...');
                } else if (gameState.questionAskedThisTurn) {
                    updateQuestionStatus('asked', 'You have already asked a question this turn.');
                } else {
                    updateQuestionStatus('ready', 'Your turn! Select a player and ask a question.');
                }
            } else {
                document.getElementById('question-status').style.display = 'none';
            }
        }

        function updateHintGameSection() {
            const giveHintSection = document.getElementById('give-hint-section');
            const isMyTurn = gameState.playerOrder?.[gameState.currentTurn]?.isYou;
            
            giveHintSection.style.display = (isMyTurn && gameState.status === 'playing') ? 'block' : 'none';
            
            // Update hint title based on game type
            const hintTitle = document.getElementById('hint-title');
            const hintLabel = document.getElementById('hint-label');
            
            if (currentGameType === 'nba') {
                hintTitle.textContent = 'üèÄ Give a Hint about your NBA Player';
                hintLabel.textContent = 'Your hint about this NBA player:';
                document.getElementById('hint-input').placeholder = 'Give a hint about your NBA player...';
            } else if (currentGameType === 'rapper') {
                hintTitle.textContent = 'üé§ Give a Hint about your Rapper';
                hintLabel.textContent = 'Your hint about this rapper:';
                document.getElementById('hint-input').placeholder = 'Give a hint about your rapper...';
            }
        }

        function updateGameScoreboard() {
            const container = document.getElementById('game-scoreboard-content');
            
            if (!scoreboardData || scoreboardData.length === 0) {
                container.innerHTML = '<p>Scoreboard will update after the round...</p>';
                return;
            }

            const topPlayers = scoreboardData.slice(0, 3);
            let html = '';
            
            topPlayers.forEach((player, index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
                const onlineStatus = player.isOnline ? '' : ' (offline)';
                const botStatus = player.isBot ? ' ü§ñ' : '';
                
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: rgba(255,255,255,0.05); margin: 0.25rem 0; border-radius: 5px;">
                        <span>${medal} ${player.name}${botStatus}${onlineStatus}</span>
                        <span class="score">${player.score}</span>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function updateDetailedScoreboard() {
            const currentTab = document.getElementById('detailed-scoreboard');
            if (scoreboardData.length === 0) {
                currentTab.innerHTML = '<p>No data available yet.</p>';
            } else {
                let html = '<table class="scoreboard-table">';
                html += '<thead><tr><th>Rank</th><th>Player</th><th>Score</th><th>Games</th><th>Win Rate</th><th>Imposter Rate</th></tr></thead>';
                html += '<tbody>';
                
                scoreboardData.forEach((player, index) => {
                    const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
                    let playerClass = '';
                    if (!player.isOnline) playerClass += 'offline ';
                    if (player.isBot) playerClass += 'bot ';
                    
                    const winRate = player.gamesPlayed > 0 ? ((player.gamesWon / player.gamesPlayed) * 100).toFixed(1) : '0';
                    const imposterRate = player.timesImposter > 0 ? ((player.timesImposterWon / player.timesImposter) * 100).toFixed(1) : '0';
                    
                    html += `
                        <tr>
                            <td><span class="rank ${rankClass}">#${index + 1}</span></td>
                            <td><span class="player-name ${playerClass}">${player.name}${player.isBot ? ' ü§ñ' : ''}</span></td>
                            <td><span class="score">${player.score}</span></td>
                            <td>${player.gamesWon}/${player.gamesPlayed}</td>
                            <td>${winRate}%</td>
                            <td>${imposterRate}%</td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
                currentTab.innerHTML = html;
            }

            const historyTab = document.getElementById('game-history-content');
            if (gameHistory.length === 0) {
                historyTab.innerHTML = '<p>No games completed yet.</p>';
            } else {
                let html = '<div class="game-history">';
                gameHistory.slice().reverse().forEach(game => {
                    const gameTypeText = game.gameType === 'nba' ? 'NBA Imposter' : 
                                        game.gameType === 'rapper' ? 'Rapper Imposter' : 'The Mole';
                    const itemText = game.gameType === 'nba' ? 'Player' : 
                                    game.gameType === 'rapper' ? 'Rapper' : 'Location';
                    
                    html += `
                        <div class="history-item">
                            <h4>${gameTypeText} Game #${game.gameNumber} - ${new Date(game.date).toLocaleString()}</h4>
                            <p><strong>${itemText}:</strong> ${game.location}</p>
                            <p><strong>Imposter:</strong> ${game.imposter}</p>
                            <p><strong>Winner:</strong> ${game.winner === 'imposter_wins' ? 'Imposter' : game.gameType === 'mole' ? 'Location Team' : 'Player Team'}</p>
                            <p><strong>Rounds:</strong> ${game.rounds}</p>
                            <details>
                                <summary>Final Scores</summary>
                                ${game.finalScores.map(score => `<p>${score.name}: ${score.score}</p>`).join('')}
                            </details>
                        </div>
                    `;
                });
                html += '</div>';
                historyTab.innerHTML = html;
            }

            const statsTab = document.getElementById('detailed-stats-content');
            if (scoreboardData.length === 0) {
                statsTab.innerHTML = '<p>No stats available yet.</p>';
            } else {
                let html = '<table class="scoreboard-table">';
                html += '<thead><tr><th>Player</th><th>Questions Asked</th><th>Questions Answered</th><th>Vote Accuracy</th><th>Rounds Survived</th></tr></thead>';
                html += '<tbody>';
                
                scoreboardData.forEach(player => {
                    const voteAccuracy = player.totalVotes > 0 ? ((player.correctVotes / player.totalVotes) * 100).toFixed(1) : '0';
                    let playerClass = '';
                    if (!player.isOnline) playerClass += 'offline ';
                    if (player.isBot) playerClass += 'bot ';
                    
                    html += `
                        <tr>
                            <td><span class="player-name ${playerClass}">${player.name}${player.isBot ? ' ü§ñ' : ''}</span></td>
                            <td>${player.questionsAsked || 0}</td>
                            <td>${player.questionsAnswered || 0}</td>
                            <td>${voteAccuracy}% (${player.correctVotes}/${player.totalVotes})</td>
                            <td>${player.roundsSurvived}</td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
                statsTab.innerHTML = html;
            }
        }

        function showVotingSection() {
            const votingSection = document.getElementById('voting-section');
            const voteOptions = document.getElementById('vote-options');
            
            voteOptions.innerHTML = '';
            
            gameState.playerOrder?.forEach(player => {
                if (!player.isYou) {
                    const button = document.createElement('button');
                    button.className = 'btn btn-danger';
                    button.textContent = `${player.name}${player.isBot ? ' ü§ñ' : ''}`;
                    button.onclick = () => submitVote(player.id);
                    voteOptions.appendChild(button);
                }
            });
            
            votingSection.style.display = 'block';
            document.getElementById('ready-to-vote-section').style.display = 'none';
            addToLog('üó≥Ô∏è Voting phase started! Choose who you think is the imposter.');
            
            // Automate bot voting
            automateBotVoting();
        }
        
        function automateBotVoting() {
            if (!gameState.playerOrder) return;
            
            // Find all bot players
            const botPlayers = gameState.playerOrder.filter(player => player.isBot);
            
            botPlayers.forEach(bot => {
                // Get all possible vote targets (excluding the bot itself)
                const possibleTargets = gameState.playerOrder.filter(player => 
                    player.id !== bot.id && !player.isBot
                );
                
                if (possibleTargets.length === 0) return;
                
                // Random delay between 2-6 seconds for more realistic behavior
                const delay = Math.random() * 4000 + 2000;
                
                setTimeout(() => {
                    // Randomly select a target
                    const randomTarget = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
                    
                    // Submit the bot's vote
                    console.log(`ü§ñ Bot ${bot.name} voting for ${randomTarget.name}`);
                    socket.emit('submit_vote', { targetId: randomTarget.id, botId: bot.id });
                    
                    // Log the bot's vote
                    addToLog(`ü§ñ ${bot.name} voted for ${randomTarget.name}`, 'info');
                }, delay);
            });
        }

        function showGameOver() {
            const resultDiv = document.getElementById('game-result');
            const summaryDiv = document.getElementById('game-summary');
            
            if (gameState.gameResult) {
                resultDiv.innerHTML = `
                    <div class="${gameState.gameResult.winner === 'location_wins' || gameState.gameResult.winner === 'player_wins' ? 'success' : 'error'}">
                        <h3>${gameState.gameResult.message}</h3>
                        <p>${currentGameType === 'mole' ? 'Location' : currentGameType === 'nba' ? 'NBA Player' : 'Rapper'}: ${gameState.gameResult.location}</p>
                        <p>Imposter: ${gameState.gameResult.imposter}</p>
                    </div>
                `;
            }

            if (gameState.gameHistory) {
                let summaryHTML = '<h4>Game Summary:</h4>';
                gameState.gameHistory.forEach(entry => {
                    if (currentGameType === 'mole') {
                        summaryHTML += `
                            <div class="log-entry">
                                <strong>${entry.asker}</strong> ‚Üí <strong>${entry.target}</strong>: ${entry.question}<br>
                                <em>${entry.answer}</em>
                            </div>
                        `;
                    } else {
                        summaryHTML += `
                            <div class="log-entry">
                                <strong>${entry.player}</strong>: ${entry.hint}
                            </div>
                        `;
                    }
                });
                summaryDiv.innerHTML = summaryHTML;
            }

            showScreen('game-over-screen');
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.container').firstChild);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.container').insertBefore(successDiv, document.querySelector('.container').firstChild);
            setTimeout(() => successDiv.remove(), 5000);
        }

        function showWarning(message) {
            const warningDiv = document.createElement('div');
            warningDiv.className = 'warning';
            warningDiv.textContent = message;
            document.querySelector('.container').insertBefore(warningDiv, document.querySelector('.container').firstChild);
            setTimeout(() => warningDiv.remove(), 5000);
        }

        function showInfo(message) {
            const infoDiv = document.createElement('div');
            infoDiv.className = 'info';
            infoDiv.textContent = message;
            document.querySelector('.container').insertBefore(infoDiv, document.querySelector('.container').firstChild);
            setTimeout(() => infoDiv.remove(), 3000);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                if (document.getElementById('answer-modal').classList.contains('active')) {
                    submitAnswer();
                } else if (document.getElementById('hint-turn-modal').classList.contains('active')) {
                    submitHintFromModal();
                }
            }
        });

        function attemptReconnection() {
            if (!disconnectedFromRoom || !disconnectTime) {
                showError('No disconnection to reconnect from');
                return;
            }
            
            const timeSinceDisconnect = Date.now() - disconnectTime;
            if (timeSinceDisconnect > 60000) {
                showError('Reconnection window expired (60 seconds)');
                disconnectedFromRoom = null;
                disconnectTime = null;
                return;
            }
            
            // Use join_room instead of separate reconnect event
            socket.emit('join_room', { 
                roomCode: disconnectedFromRoom.roomCode, 
                playerName: disconnectedFromRoom.playerName,
                gameType: currentGameType
            });
        }

        function checkForReconnection() {
            if (disconnectedFromRoom && disconnectTime && !leftRoom) {
                const timeSinceDisconnect = Date.now() - disconnectTime;
                const timeLeft = Math.max(0, 60000 - timeSinceDisconnect);
                
                if (timeLeft > 0) {
                    showWarning(`You were disconnected from room ${disconnectedFromRoom.roomCode}. You can reconnect for ${Math.ceil(timeLeft / 1000)} more seconds.`);
                    
                    // Add reconnection button to home screen
                    const homeScreen = document.getElementById('home-screen');
                    let reconnectBtn = document.getElementById('reconnect-btn');
                    if (!reconnectBtn) {
                        reconnectBtn = document.createElement('button');
                        reconnectBtn.id = 'reconnect-btn';
                        reconnectBtn.className = 'btn btn-warning';
                        reconnectBtn.onclick = attemptReconnection;
                        homeScreen.querySelector('.card').appendChild(reconnectBtn);
                    }
                    reconnectBtn.textContent = `üîÑ Reconnect to ${disconnectedFromRoom.roomCode} (${Math.ceil(timeLeft / 1000)}s)`;
                    reconnectBtn.style.display = 'inline-block';
                    
                    // Show join room section with room code pre-filled
                    document.getElementById('join-room-section').style.display = 'block';
                    document.getElementById('room-code').value = disconnectedFromRoom.roomCode;
                } else {
                    // Reconnection window expired
                    disconnectedFromRoom = null;
                    disconnectTime = null;
                    const reconnectBtn = document.getElementById('reconnect-btn');
                    if (reconnectBtn) {
                        reconnectBtn.style.display = 'none';
                    }
                    showError('Reconnection window expired. You can join a new room.');
                }
            }
        }

        let leftRoom = false; // Track if player left intentionally
        function leaveRoom() {
            console.log('üö™ leaveRoom called');
            console.log('üö™ Current state - currentGameType:', currentGameType, 'currentRoom:', currentRoom, 'isHost:', isHost);
            leftRoom = true;
            socket.emit('leave_room');
            showScreen('home-screen');
            showInfo('You left the room.');
            console.log('üö™ Left room, leftRoom flag set to:', leftRoom);
        }

        // NEW: Leave button for game screen
        function leaveGame() {
            showModal('leave-game-modal');
        }

        // NEW: Leave game confirmation modal
        function confirmLeaveGame() {
            hideModal('leave-game-modal');
            leaveRoom();
        }

        // === SPOTIFY INTEGRATION (FIXED) ===
        const spotifyClientId = '4e94cdc6f9c544f8a74b67e5bf31a5bb';
        const spotifyRedirectUri = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
            ? 'http://127.0.0.1:8888/callback'
            : 'https://jaceg22-github-io.onrender.com/callback';

        let spotifyAccessToken = null;
        let spotifyPlayer = null;
        let spotifyPlayerReady = false;
        let spotifyIsPremium = false;
        let spotifyCurrentTrack = null;
        let spotifyIsPlaying = false;
        let spotifyDeviceId = null;
        let spotifyUserProfile = null;

        // Custom Queue Management Variables
        let spotifyCustomQueue = [];
        let spotifyQueueIndex = 0;
        let spotifyQueueEnabled = false;
        let spotifyCurrentSource = null; // tracks the source (playlist, top-tracks, etc.)
        let spotifyOriginalList = []; // stores the original list before shuffle

        function setupSpotifyLoginButton() {
            const loginBtnIds = [
                'spotify-login-btn',
                'spotify-login-btn-lobby',
                'spotify-login-btn-game',
                'spotify-login-btn-gameover'
            ];
            
            loginBtnIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.onclick = function() {
                        const scope = 'streaming user-read-email user-read-private user-modify-playback-state user-read-playback-state user-read-recently-played user-read-currently-playing user-top-read playlist-read-private playlist-read-collaborative';
                        const authUrl = `https://accounts.spotify.com/authorize?response_type=code&client_id=${spotifyClientId}&scope=${encodeURIComponent(scope)}&redirect_uri=${encodeURIComponent(spotifyRedirectUri)}`;
                        window.open(authUrl, 'spotify-login', 'width=500,height=700');
                    };
                }
            });
        }

        function setupSpotifyOpenMusicButton() {
            const openMusicBtnIds = [
                'spotify-open-music-btn',
                'spotify-open-music-btn-selection',
                'spotify-open-music-btn-lobby',
                'spotify-open-music-btn-game',
                'spotify-open-music-btn-gameover'
            ];
            openMusicBtnIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        // Use page-specific functions
                        if (id === 'spotify-open-music-btn') {
                            openSpotifyFromSelection();
                        } else if (id === 'spotify-open-music-btn-lobby') {
                            openSpotifyFromLobby();
                        } else if (id === 'spotify-open-music-btn-game') {
                            openSpotifyFromGame();
                        } else if (id === 'spotify-open-music-btn-gameover') {
                            openSpotifyFromGameOver();
                        } else {
                            openSpotifyDashboard(); // fallback
                        }
                    };
                }
            });
        }

        function updateSpotifyButtons() {
            updateSpotifyButtonsOnAllScreens();
        }

        // Update Spotify buttons on all screens
        function updateSpotifyButtonsOnAllScreens() {
            const buttonIds = [
                'spotify-login-btn', 'spotify-open-music-btn',
                'spotify-login-btn-lobby', 'spotify-open-music-btn-lobby',
                'spotify-login-btn-game', 'spotify-open-music-btn-game',
                'spotify-login-btn-gameover', 'spotify-open-music-btn-gameover'
            ];
            
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (id.includes('login')) {
                        btn.style.display = spotifyAccessToken ? 'none' : 'inline-block';
                    } else if (id.includes('open-music')) {
                        btn.style.display = spotifyAccessToken ? 'inline-block' : 'none';
                    }
                }
            });
        }

        window.addEventListener('message', (event) => {
            if (event.data && event.data.access_token) {
                spotifyAccessToken = event.data.access_token;
                showSuccess('Spotify connected!');
                getSpotifyUserProfile();
                initializeSpotifyWebPlayback();
                updateSpotifyButtons();
                updateSpotifyButtonsOnAllScreens();
            }
        });

        async function getSpotifyUserProfile() {
            try {
                const response = await fetch('https://api.spotify.com/v1/me', {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                spotifyUserProfile = await response.json();
                spotifyIsPremium = spotifyUserProfile.product === 'premium';
                if (!spotifyIsPremium) {
                    showSpotifyPremiumWarning('Spotify Premium is required for full playback. You can play 30s previews.');
                } else {
                    hideSpotifyPremiumWarning();
                }
                loadSpotifyUserProfileUI();
                console.log('Spotify user profile loaded:', spotifyUserProfile);
            } catch (error) {
                console.error('Failed to load Spotify user profile:', error);
                showError('Failed to load Spotify profile: ' + error.message);
            }
        }

        function loadSpotifyUserProfileUI() {
            const profileDiv = document.getElementById('spotify-user-profile');
            if (profileDiv && spotifyUserProfile) {
                let html = '';
                if (spotifyUserProfile.images && spotifyUserProfile.images[0]) {
                    html += `<img src="${spotifyUserProfile.images[0].url}" style="width:70px;height:70px;border-radius:50%;margin-bottom:0.5rem;">`;
                }
                html += `<div style="font-weight:bold;">${spotifyUserProfile.display_name || spotifyUserProfile.id}</div>`;
                profileDiv.innerHTML = html;
            }
        }

        function initializeSpotifyWebPlayback() {
            if (!window.Spotify) {
                console.error('Spotify Web Playback SDK not loaded');
                showSpotifyPremiumWarning('Spotify Web Playback SDK not loaded.');
                return;
            }
            if (!spotifyAccessToken) return;
            if (spotifyPlayer) {
                spotifyPlayer.disconnect();
                spotifyPlayer = null;
            }
            spotifyPlayer = new Spotify.Player({
                name: 'Game Collection Web Player',
                getOAuthToken: cb => { cb(spotifyAccessToken); },
                volume: 0.8
            });
            spotifyPlayer.addListener('ready', ({ device_id }) => {
                console.log('Spotify player ready with device ID:', device_id);
                spotifyPlayerReady = true;
                spotifyDeviceId = device_id;
            });
            spotifyPlayer.addListener('not_ready', ({ device_id }) => {
                console.log('Spotify player not ready:', device_id);
                spotifyPlayerReady = false;
            });
            spotifyPlayer.addListener('player_state_changed', state => {
                if (!state) return;
                
                // Check if we've moved to a new track
                const newTrack = state.track_window.current_track;
                const trackChanged = spotifyCurrentTrack && newTrack && spotifyCurrentTrack.id !== newTrack.id;
                const playbackStateChanged = spotifyIsPlaying !== !state.paused;
                
                if (trackChanged) {
                    // Reset auto-advance flag for new track
                    hasAutoAdvanced = false;
                    console.log('üéµ New track detected:', newTrack.name, 'by', newTrack.artists[0]?.name);
                    console.log('üéµ Reset auto-advance flag. Queue enabled:', spotifyQueueEnabled);
                    console.log('üéµ Current queue index:', spotifyQueueIndex, '/', spotifyCustomQueue.length);
                }
                
                spotifyCurrentTrack = newTrack;
                spotifyIsPlaying = !state.paused;
                updateSpotifyPlayerBar();
                
                // Update dashboard "Currently Playing" section if it's visible
                if (trackChanged || playbackStateChanged) {
                    updateDashboardCurrentlyPlaying(newTrack, !state.paused);
                }
                
                // Start/stop progress tracking based on playback state
                if (!state.paused) {
                    startProgressTracking();
                } else {
                    stopProgressTracking();
                }
            });
            spotifyPlayer.addListener('initialization_error', ({ message }) => {
                console.error('Spotify initialization error:', message);
            });
            spotifyPlayer.addListener('authentication_error', ({ message }) => {
                console.error('Spotify authentication error:', message);
                showError('Spotify authentication error. Please login again.');
            });
            spotifyPlayer.addListener('account_error', ({ message }) => {
                console.error('Spotify account error:', message);
                showSpotifyPremiumWarning('Spotify Premium required for web playback.');
            });
            spotifyPlayer.connect().then(success => {
                if (success) {
                    console.log('Successfully connected to Spotify');
                } else {
                    console.error('Failed to connect to Spotify');
                }
            });
        }

        function showSpotifyPremiumWarning(msg) {
            const warning = document.getElementById('spotify-premium-warning');
            if (warning) {
                warning.textContent = msg;
                warning.style.display = 'block';
            }
        }

        function hideSpotifyPremiumWarning() {
            const warning = document.getElementById('spotify-premium-warning');
            if (warning) {
                warning.style.display = 'none';
            }
        }

        function showSpotifyApp() {
            openSpotifyDashboard();
        }

        // Global data preloader to avoid repeated loading
        async function preloadSpotifyData() {
            if (!spotifyAccessToken) return;
            
            console.log('üîÑ Pre-loading all Spotify data...');
            try {
                // Force fresh calculation of listening stats (not quick mode)
                const now = Date.now();
                if (!cachedListeningStats || (now - cacheTimestamp) > 30000) { // 30 second cache for preload
                    await getCachedListeningStats(false); // Full calculation
                    console.log('‚úÖ Pre-loaded listening stats with full analysis');
                }
            } catch (error) {
                console.error('Error pre-loading Spotify data:', error);
            }
        }

        // Page-specific Spotify dashboard functions
        function openSpotifyFromSelection() {
            if (!spotifyAccessToken) {
                showError('Please login to Spotify first');
                return;
            }
            console.log('üéµ Opening Spotify from selection screen...');
            showModal('spotify-popup');
            preloadSpotifyData();
            showSpotifyDashboard();
        }

        function openSpotifyFromLobby() {
            if (!spotifyAccessToken) {
                showError('Please login to Spotify first');
                return;
            }
            console.log('üéµ Opening Spotify from lobby screen...');
            showModal('spotify-popup');
            showSpotifyDashboard();
        }
        
        function openSpotifyFromGame() {
            if (!spotifyAccessToken) {
                showError('Please login to Spotify first');
                return;
            }
            console.log('üéµ Opening Spotify from game screen...');
            showModal('spotify-popup');
            showSpotifyDashboard();
        }
        
        function openSpotifyFromGameOver() {
            if (!spotifyAccessToken) {
                showError('Please login to Spotify first');
                return;
            }
            console.log('üéµ Opening Spotify from game over screen...');
            showModal('spotify-popup');
            showSpotifyDashboard();
        }
        
        function openSpotifyDashboard() {
            // Default fallback - redirect to lobby function
            openSpotifyFromLobby();
        }

        let spotifyDashboardUpdateInterval = null;

        function showSpotifyHome() {
            const main = document.getElementById('spotify-main');
            main.innerHTML = '<div style="text-align:center;padding:2rem;"><span class="loading-spinner"></span> Loading Home...</div>';
            renderSpotifyHome();
            
            // Clear any existing periodic updates since we now use real-time events
            if (spotifyDashboardUpdateInterval) {
                clearInterval(spotifyDashboardUpdateInterval);
                spotifyDashboardUpdateInterval = null;
            }
            console.log('üè† Home loaded with real-time updates');
        }

        async function calculateListeningStats(recentTracks, topTracks, playlists) {
            const results = {
                generalGenreStats: {},
                listeningTimeByGenre: {},
                topGenres: [],
                studySongs: [],
                listeningPatterns: {
                    morningVibes: { genre: 'Various', percentage: 0 },
                    eveningChoice: { genre: 'Various', percentage: 0 },
                    studyMode: { genre: 'Various', percentage: 0 },
                    windDown: { genre: 'Various', percentage: 0 },
                    mostReplayed: { type: 'Various', content: 'Your playlists' }
                }
            };

            // First collect genres from top artists to have baseline data
            if (topTracks && topTracks.length > 0) {
                for (const track of topTracks.slice(0, 10)) {
                    if (track.artists && track.artists.length > 0) {
                        try {
                            const artist = track.artists[0];
                            const artistData = await getCachedArtistData(artist.id);
                            if (artistData && artistData.genres) {
                                for (const genre of artistData.genres) {
                                    if (!results.generalGenreStats[genre]) {
                                        results.generalGenreStats[genre] = 0;
                                    }
                                    results.generalGenreStats[genre] += track.duration_ms || 180000;
                                    
                                    if (!results.listeningTimeByGenre[genre]) {
                                        results.listeningTimeByGenre[genre] = 0;
                                    }
                                    results.listeningTimeByGenre[genre] += track.duration_ms || 180000;
                                }
                            }
                        } catch (error) {
                            console.log('Error fetching artist data:', error);
                        }
                    }
                }
            }

            // Analyze listening behavior patterns by time of day from recent tracks
            const morningGenres = new Map(); // 6am-12pm
            const daytimeGenres = new Map(); // 12pm-8pm  
            const nightGenres = new Map(); // 8pm-5am
            const studyGenres = new Map(); // from playlists
            
            // Analyze recent tracks by time of day
            if (recentTracks && recentTracks.length > 0) {
                for (const item of recentTracks) {
                    if (!item.played_at || !item.track || !item.track.artists) continue;
                    
                    const playedAt = new Date(item.played_at);
                    const hour = playedAt.getHours();
                    const track = item.track;
                    
                    // Get genres for this track's artist (with rate limiting)
                    try {
                        const artist = track.artists[0];
                        const artistData = await getCachedArtistData(artist.id);
                        if (artistData && artistData.genres) {
                            for (const genre of artistData.genres) {
                                const duration = track.duration_ms || 180000;
                                
                                // Categorize by time of day
                                if (hour >= 6 && hour < 12) {
                                    // Morning: 6am-12pm
                                    morningGenres.set(genre, (morningGenres.get(genre) || 0) + duration);
                                } else if (hour >= 12 && hour < 20) {
                                    // Daytime: 12pm-8pm
                                    daytimeGenres.set(genre, (daytimeGenres.get(genre) || 0) + duration);
                                } else {
                                    // Night: 8pm-5am
                                    nightGenres.set(genre, (nightGenres.get(genre) || 0) + duration);
                                }
                            }
                        }
                    } catch (error) {
                        console.log('Error fetching artist data for time analysis:', error);
                    }
                }
            }
            
            // Analyze study patterns from playlists
            const studyKeywords = ['focus', 'study', 'schoo', 'work', 'concentration', 'academic', 'homework'];
            
            // Helper function to check for study keyword matching (chill allowed if combined with study words)
            const matchesStudyKeywords = (name) => {
                const studyPatterns = [
                    /\bfocus\w*/i,      // focus, focused, focusing, etc.
                    /\bstud\w*/i,       // study, studying, studyyyy, etc.
                    /\bschoo\w*/i,      // school, schoolwork, etc.
                    /\bwork\w*/i,       // work, working, homework, etc.
                    /\blofi\b/i,        // lofi exactly
                    /\blo-fi\b/i,       // lo-fi exactly
                    /\blo\s+fi\b/i,     // lo fi with space
                    /\bambient\w*/i     // ambient, ambience, etc.
                ];
                
                // Check if it has "chill" - only allow if combined with study keywords
                if (/\bchill\w*/i.test(name)) {
                    return studyPatterns.some(pattern => pattern.test(name));
                }
                
                // For non-chill names, check normal study patterns
                return studyPatterns.some(pattern => pattern.test(name));
            };

            // Collect study playlists and their tracks for genre analysis
            const studyPlaylistIds = [];
            if (playlists && playlists.length > 0) {
                for (const playlist of playlists) {
                    const playlistName = playlist.name.toLowerCase();
                    
                    // Check for study patterns with strict matching (no chill)
                    if (matchesStudyKeywords(playlistName)) {
                        console.log(`üìö Found study playlist: "${playlist.name}" (${playlist.tracks?.total || 0} tracks)`);
                        studyPlaylistIds.push(playlist.id);
                    }
                }
            }
            
            // Get genres from actual study playlist tracks
            for (const playlistId of studyPlaylistIds) {
                try {
                    const playlistTracks = await makeSpotifyRequest(`playlists/${playlistId}/tracks`, { limit: 50 });
                    if (playlistTracks && playlistTracks.items) {
                        for (const item of playlistTracks.items) {
                            if (item && item.track && item.track.artists) {
                                const track = item.track;
                                const artist = track.artists[0];
                                
                                // Skip if artist ID is invalid or missing
                                if (!artist || !artist.id || artist.id === '1n2COPO0d7tjO4rHYZFLZY') {
                                    continue;
                                }
                                
                                try {
                                    const artistData = await getCachedArtistData(artist.id);
                                    if (artistData && artistData.genres) {
                                        for (const genre of artistData.genres) {
                                            const duration = track.duration_ms || 180000;
                                            studyGenres.set(genre, (studyGenres.get(genre) || 0) + duration);
                                        }
                                    }
                                } catch (error) {
                                    console.log('Error fetching artist data for study genre:', error);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.log('Error fetching study playlist tracks:', error);
                }
            }
            
            // Sort genres by listening time
            const sortedGenres = Object.entries(results.generalGenreStats)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);
            
            results.topGenres = sortedGenres.map(([genre, time]) => ({
                genre,
                time,
                formattedTime: formatTime(time)
            }));
            
            // Determine most common patterns based on time-based listening
            const getTopGenres = (genreMap, count = 3) => {
                if (genreMap.size === 0) return [];
                const sorted = Array.from(genreMap.entries()).sort((a, b) => b[1] - a[1]);
                return sorted.slice(0, count).map(([genre, time]) => ({ genre, time }));
            };
            
            // Store time-based patterns for display with proper percentages
            const calculateGenrePercentages = (genreMap) => {
                if (genreMap.size === 0) return [];
                const sorted = Array.from(genreMap.entries()).sort((a, b) => b[1] - a[1]);
                const totalTime = Array.from(genreMap.values()).reduce((sum, time) => sum + time, 0);
                return sorted.slice(0, 3).map(([genre, time]) => ({
                    genre,
                    time,
                    percentage: totalTime > 0 ? Math.round((time / totalTime) * 100) : 0
                }));
            };
            
            results.timeBasedGenres = {
                morning: calculateGenrePercentages(morningGenres),
                daytime: calculateGenrePercentages(daytimeGenres), 
                night: calculateGenrePercentages(nightGenres),
                study: calculateGenrePercentages(studyGenres)
            };
            
            // Legacy patterns for backwards compatibility
            const getTopGenre = (genreMap) => {
                if (genreMap.size === 0) return { genre: 'Various', percentage: 0 };
                const sorted = Array.from(genreMap.entries()).sort((a, b) => b[1] - a[1]);
                const total = Array.from(genreMap.values()).reduce((sum, val) => sum + val, 0);
                const percentage = total > 0 ? Math.round((sorted[0][1] / total) * 100) : 0;
                return { genre: sorted[0][0], percentage };
            };
            
            results.listeningPatterns.morningVibes = getTopGenre(morningGenres);
            results.listeningPatterns.eveningChoice = getTopGenre(daytimeGenres); // Changed from eveningGenres
            results.listeningPatterns.studyMode = getTopGenre(studyGenres);
            results.listeningPatterns.windDown = getTopGenre(nightGenres); // Changed from windDownGenres
            
            // Fallback patterns based on top genres if no playlist patterns found
            if (results.listeningPatterns.morningVibes.percentage === 0 && results.topGenres.length > 0) {
                const chillGenres = results.topGenres.filter(g => 
                    ['chill', 'ambient', 'acoustic', 'folk', 'jazz'].some(term => g.genre.toLowerCase().includes(term))
                );
                if (chillGenres.length > 0) {
                    results.listeningPatterns.morningVibes = { 
                        genre: chillGenres[0].genre, 
                        percentage: Math.min(68, Math.round(Math.random() * 30) + 50) 
                    };
                }
            }
            
            if (results.listeningPatterns.eveningChoice.percentage === 0 && results.topGenres.length > 0) {
                const eveningGenres = results.topGenres.filter(g => 
                    ['pop', 'hip hop', 'r&b', 'bollywood', 'hindi'].some(term => g.genre.toLowerCase().includes(term))
                );
                if (eveningGenres.length > 0) {
                    results.listeningPatterns.eveningChoice = { 
                        genre: eveningGenres[0].genre, 
                        percentage: Math.min(45, Math.round(Math.random() * 20) + 30) 
                    };
                }
            }
            
            if (results.listeningPatterns.studyMode.percentage === 0) {
                results.listeningPatterns.studyMode = { 
                    genre: 'Lo-fi beats', 
                    percentage: 82 
                };
            }

            // Collect study songs from study playlists and track analysis
            console.log('üéµ Analyzing study songs...');
            const studySongs = new Set();
            const recentStudySongs = new Set();
            
            // Helper function to check if a song is study-related (strict - no chill)
            const isStudySong = (track) => {
                if (!track || !track.name) return false;
                
                const trackName = track.name.toLowerCase();
                const artistNames = track.artists?.map(a => a.name?.toLowerCase() || '').join(' ') || '';
                const albumName = track.album?.name?.toLowerCase() || '';
                const searchText = `${trackName} ${artistNames} ${albumName}`;
                
                return matchesStudyKeywords(searchText);
            };
            
            // Check songs from study playlists (already collected above during genre analysis)
            for (const playlistId of studyPlaylistIds) {
                try {
                    const playlistTracks = await makeSpotifyRequest(`playlists/${playlistId}/tracks`, { limit: 50 });
                    if (playlistTracks && playlistTracks.items) {
                        for (const item of playlistTracks.items) {
                            if (item && item.track && item.track.id) {
                                studySongs.add(JSON.stringify({
                                    id: item.track.id,
                                    name: item.track.name,
                                    artists: item.track.artists?.map(a => a.name) || [],
                                    album: item.track.album?.name || '',
                                    images: item.track.album?.images || [],
                                    source: 'study_playlist',
                                    playlist_name: playlistTracks.name || 'Study Playlist'
                                }));
                            }
                        }
                    }
                } catch (error) {
                    console.log('Error fetching study playlist tracks for songs:', error);
                }
            }
            
            // Check songs from recent tracks for study keywords or if they're from study playlists
            if (recentTracks && recentTracks.length > 0) {
                for (const item of recentTracks) {
                    const track = item.track || item;
                    if (track && (isStudySong(track) || Array.from(studySongs).some(songStr => JSON.parse(songStr).id === track.id))) {
                        recentStudySongs.add(JSON.stringify({
                            id: track.id,
                            name: track.name,
                            artists: track.artists?.map(a => a.name) || [],
                            album: track.album?.name || '',
                            images: track.album?.images || [],
                            source: 'recent_study',
                            played_at: item.played_at
                        }));
                    }
                }
            }
            
            // Check songs from top tracks for study keywords
            if (topTracks && topTracks.length > 0) {
                for (const track of topTracks) {
                    if (track && isStudySong(track)) {
                        studySongs.add(JSON.stringify({
                            id: track.id,
                            name: track.name,
                            artists: track.artists?.map(a => a.name) || [],
                            album: track.album?.name || '',
                            images: track.album?.images || [],
                            source: 'top_tracks_keyword'
                        }));
                    }
                }
            }
            
            // Convert back to arrays
            results.studySongs = Array.from(studySongs).map(songStr => JSON.parse(songStr)).slice(0, 50);
            results.recentStudySongs = Array.from(recentStudySongs).map(songStr => JSON.parse(songStr)).slice(0, 20);
            
            console.log(`üéµ Found ${results.studySongs.length} total study songs, ${results.recentStudySongs.length} recent study songs`);

            // Add raw data for direct access
            results.recentTracks = recentTracks;
            results.topTracks = topTracks;
            results.playlists = playlists;

            return results;
        }

        // Get study music recommendations with smart fallback
        async function getStudyRecommendations(studySongs, recentStudySongs) {
            console.log('üéØ Getting study recommendations...');
            let recommendations = [];
            
            try {
                // Strategy 1: Use recently played study songs for recommendations
                if (recentStudySongs && recentStudySongs.length >= 3) {
                    console.log('üéØ Using recent study songs for recommendations');
                    const seedTracks = recentStudySongs.slice(0, 5).map(s => s.id).join(',');
                    const response = await makeSpotifyRequest('recommendations', {
                        seed_tracks: seedTracks,
                        limit: 20,
                        target_acousticness: 0.7,
                        target_energy: 0.4,
                        target_valence: 0.5
                    });
                    if (response && response.tracks) {
                        recommendations = response.tracks.map(track => ({
                            ...track,
                            recommendation_source: 'recent_study_songs'
                        }));
                    }
                }
                
                // Strategy 2: Use all study songs if we don't have enough recent ones
                if (recommendations.length === 0 && studySongs && studySongs.length >= 3) {
                    console.log('üéØ Using all study songs for recommendations');
                    try {
                        const seedTracks = studySongs.slice(0, 5).map(s => s.id).join(',');
                        const response = await makeSpotifyRequest('recommendations', {
                            seed_tracks: seedTracks,
                            limit: 20,
                            target_acousticness: 0.7,
                            target_energy: 0.4,
                            target_valence: 0.5
                        });
                        if (response && response.tracks) {
                            recommendations = response.tracks.map(track => ({
                                ...track,
                                recommendation_source: 'study_songs'
                            }));
                        }
                    } catch (error) {
                        console.warn('Failed to get recommendations from study songs:', error);
                    }
                }
                
                // Strategy 3: Fallback to popular study music seeds
                if (recommendations.length === 0) {
                    console.log('üéØ Using popular study music seeds as fallback');
                    try {
                        const studyGenres = ['lo-fi', 'ambient', 'instrumental-hip-hop', 'chill', 'focus'];
                        const seedGenres = studyGenres.slice(0, 5).join(',');
                        const response = await makeSpotifyRequest('recommendations', {
                            seed_genres: seedGenres,
                            limit: 20,
                            target_acousticness: 0.8,
                            target_energy: 0.3,
                            target_valence: 0.4,
                            target_instrumentalness: 0.7
                        });
                        if (response && response.tracks) {
                            recommendations = response.tracks.map(track => ({
                                ...track,
                                recommendation_source: 'popular_study'
                            }));
                        }
                    } catch (error) {
                        console.warn('Failed to get recommendations from popular study genres:', error);
                    }
                }
                
                // Strategy 4: Final fallback to search for popular study playlists
                if (recommendations.length === 0) {
                    console.log('üéØ Using study playlist search as final fallback');
                    const searchResponse = await makeSpotifyRequest('search', {
                        q: 'lofi study focus instrumental',
                        type: 'playlist',
                        limit: 1
                    });
                    if (searchResponse && searchResponse.playlists && searchResponse.playlists.items.length > 0) {
                        const playlist = searchResponse.playlists.items[0];
                        const tracksResponse = await makeSpotifyRequest(`playlists/${playlist.id}/tracks`, { limit: 20 });
                        if (tracksResponse && tracksResponse.items) {
                            recommendations = tracksResponse.items
                                .filter(item => item.track)
                                .map(item => ({
                                    ...item.track,
                                    recommendation_source: 'study_playlist_search'
                                }));
                        }
                    }
                }
                
                console.log(`üéØ Found ${recommendations.length} study recommendations`);
                return recommendations.slice(0, 20);
                
            } catch (error) {
                console.error('Error getting study recommendations:', error);
                return [];
            }
        }

        function getTopAlbumsFromTracks(tracks) {
            const albumCounts = new Map();
            
            tracks.forEach(track => {
                if (track.album) {
                    const albumKey = track.album.id;
                    if (!albumCounts.has(albumKey)) {
                        albumCounts.set(albumKey, {
                            album: track.album,
                            count: 0
                        });
                    }
                    albumCounts.get(albumKey).count++;
                }
            });
            
            return Array.from(albumCounts.values())
                .sort((a, b) => b.count - a.count)
                .slice(0, 10)
                .map(item => item.album);
        }

        function showSpotifyStudyStats() {
            const main = document.getElementById('spotify-main');
            main.innerHTML = '<div style="text-align:center;padding:2rem;"><span class="loading-spinner"></span> Loading Study Stats...</div>';
            renderSpotifyStudyStats();
        }

        function showSpotifyStudyRecommendations() {
            const main = document.getElementById('spotify-main');
            main.innerHTML = '<div style="text-align:center;padding:2rem;"><span class="loading-spinner"></span> Loading Study Recommendations...</div>';
            renderSpotifyStudyRecommendations();
        }

        async function renderSpotifyStudyStats() {
    const main = document.getElementById('spotify-main');
    try {
                // Fetch study-related data
                const [playlistsRes, recentRes, audioFeaturesRes] = await Promise.allSettled([
                    fetch('https://api.spotify.com/v1/me/playlists?limit=50', { headers: { 'Authorization': 'Bearer ' + spotifyAccessToken } }),
                    fetch('https://api.spotify.com/v1/me/player/recently-played?limit=50', { headers: { 'Authorization': 'Bearer ' + spotifyAccessToken } }),
                    fetch('https://api.spotify.com/v1/me/top/tracks?limit=20', { headers: { 'Authorization': 'Bearer ' + spotifyAccessToken } })
                ]);

                const playlists = playlistsRes.status === 'fulfilled' && playlistsRes.value.ok ? await playlistsRes.value.json() : { items: [] };
                const recent = recentRes.status === 'fulfilled' && recentRes.value.ok ? await recentRes.value.json() : { items: [] };
                const topTracks = audioFeaturesRes.status === 'fulfilled' && audioFeaturesRes.value.ok ? await audioFeaturesRes.value.json() : { items: [] };

                // Filter study playlists using keywords (chill allowed if combined with study words)
                const matchesStudyKeywords = (name) => {
                    const studyPatterns = [
                        /\bfocus\w*/i, /\bstud\w*/i, /\bschoo\w*/i, /\bwork\w*/i,
                        /\blofi\b/i, /\blo-fi\b/i, /\blo\s+fi\b/i, /\bambient\w*/i
                    ];
                    // Check if it has "chill" - only allow if combined with study keywords
                    if (/\bchill\w*/i.test(name)) {
                        return studyPatterns.some(pattern => pattern.test(name));
                    }
                    // For non-chill names, check normal study patterns
                    return studyPatterns.some(pattern => pattern.test(name));
                };
                
                const studyPlaylists = playlists.items.filter(pl => 
                    pl && pl.name && matchesStudyKeywords(pl.name.toLowerCase())
                );

                let html = `<h2 class="glow-title" style="font-size:2.5rem;margin-bottom:2rem;">üìä Study Stats</h2>`;
                
                // Study Overview
                html += `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:1.5rem;margin-bottom:2rem;">
                    <div style="background:#1c253b;padding:1.5rem;border-radius:20px;text-align:center;">
                        <h3 style="color:#1db954;margin-bottom:1rem;">üìö Study Playlists</h3>
                        <p style="font-size:2rem;font-weight:bold;">${studyPlaylists.length}</p>
                    </div>
                    <div style="background:#1c253b;padding:1.5rem;border-radius:20px;text-align:center;">
                        <h3 style="color:#1db954;margin-bottom:1rem;">üéß Recent Listening</h3>
                        <p style="font-size:2rem;font-weight:bold;">${recent.items.length}</p>
                    </div>
                    <div style="background:#1c253b;padding:1.5rem;border-radius:20px;text-align:center;">
                        <h3 style="color:#1db954;margin-bottom:1rem;">‚≠ê Top Tracks</h3>
                        <p style="font-size:2rem;font-weight:bold;">${topTracks.items.length}</p>
                    </div>
                </div>`;

                // Top Study Playlists
                if (studyPlaylists.length > 0) {
                    html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                        <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üìö Your Study Playlists</h3>
                        <div style="max-height:400px;overflow-y:auto;">`;
                    
                    studyPlaylists.slice(0, 10).forEach((pl, i) => {
                        const artwork = pl.images && pl.images.length > 0 ? pl.images[0].url : '';
                        html += `<div class="track-item" onclick="showSpotifyPlaylistApp('${pl.id}','${pl.name.replace(/'/g, "&#39;")}')" style="cursor:pointer;">
                            ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üìö</div>'}
                            <div class="track-info">
                                <div class="track-name">${i+1}. ${pl.name}</div>
                                <div class="track-artist">üéµ ${pl.tracks.total} tracks ‚Ä¢ ${pl.description || 'Study playlist'}</div>
                            </div>
                            <div class="track-actions">
                                <button class="btn btn-primary" onclick="event.stopPropagation(); playEntirePlaylist('${pl.id}')" title="Play first song and queue the rest">‚ñ∂Ô∏è Play</button>
                            </div>
                        </div>`;
                    });
                    html += '</div></div>';
                }

                // Get study tracks using cached listening stats
                const listeningStats = await getCachedListeningStats();
                
                // Study Tracks with smart fallback
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üéµ Study Tracks</h3>
                    <div style="max-height:400px;overflow-y:auto;">`;

                let tracksToShow = [];
                let sourceDescription = '';
                
                // Priority 1: Recent study tracks
                if (listeningStats.recentStudySongs && listeningStats.recentStudySongs.length > 0) {
                    tracksToShow = listeningStats.recentStudySongs.slice(0, 15);
                    sourceDescription = 'Recently played study tracks';
                }
                // Priority 2: Any study tracks from playlists
                else if (listeningStats.studySongs && listeningStats.studySongs.length > 0) {
                    tracksToShow = listeningStats.studySongs.slice(0, 15);
                    sourceDescription = 'Study tracks from your playlists';
                }
                
                if (tracksToShow.length > 0) {
                    html += `<p style="margin-bottom:1rem;color:#b3b3b3;font-size:0.9rem;">${sourceDescription}</p>`;
                    tracksToShow.forEach((track, i) => {
                        const artwork = track.images?.[0]?.url || track.album?.images?.[0]?.url || '';
                        const artistNames = track.artists?.join ? track.artists.join(', ') : 
                                          track.artists?.map ? track.artists.map(a => a.name).join(', ') : 'Unknown Artist';
                        html += `<div class="track-item">
                            ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üéµ</div>'}
                            <div class="track-info">
                                <div class="track-name">${i+1}. ${track.name}</div>
                                <div class="track-artist">by ${artistNames}</div>
                            </div>
                            <div class="track-actions">
                                <button class="btn btn-primary btn-sm" onclick="playSpotifyTrackId('${track.id}')">‚ñ∂Ô∏è Play</button>
                                <button class="btn btn-secondary btn-sm" onclick="addSearchTrackToQueue('${track.id}', false)">Queue</button>
                            </div>
                        </div>`;
                    });
                } else {
                    html += '<div style="text-align:center;padding:2rem;color:#b3b3b3;">No study tracks found. Create playlists with "study", "work", "focus", "lofi", or "ambient" in the name and add some tracks!</div>';
                }
                html += '</div></div>';

                main.innerHTML = html;
            } catch (error) {
                console.error('Error loading study stats:', error);
                main.innerHTML = '<div style="text-align:center;padding:2rem;color:#ff6b6b;">Error loading study stats</div>';
            }
        }

        async function renderSpotifyStudyRecommendations() {
            const main = document.getElementById('spotify-main');
            try {
                // Get study data using cached listening stats
                const listeningStats = await getCachedListeningStats();
                
                // Get smart study recommendations
                const studyRecommendations = await getStudyRecommendations(listeningStats.studySongs, listeningStats.recentStudySongs);
                
                let html = `<h2 class="glow-title" style="font-size:2.5rem;margin-bottom:2rem;">üéØ Study Recommendations</h2>`;
                
                // Find study playlists using filtering (chill allowed if combined with study words)
                const matchesStudyKeywords = (name) => {
                    const studyPatterns = [
                        /\bfocus\w*/i, /\bstud\w*/i, /\bschoo\w*/i, /\bwork\w*/i,
                        /\blofi\b/i, /\blo-fi\b/i, /\blo\s+fi\b/i, /\bambient\w*/i
                    ];
                    // Check if it has "chill" - only allow if combined with study keywords
                    if (/\bchill\w*/i.test(name)) {
                        return studyPatterns.some(pattern => pattern.test(name));
                    }
                    // For non-chill names, check normal study patterns
                    return studyPatterns.some(pattern => pattern.test(name));
                };
                
                let studyPlaylists = [];
                if (listeningStats.playlists && listeningStats.playlists.length > 0) {
                    studyPlaylists = listeningStats.playlists.filter(playlist => {
                        if (!playlist || !playlist.name) return false;
                        return matchesStudyKeywords(playlist.name.toLowerCase());
                    }).slice(0, 8);
                }
                
                // Smart Study Recommendations
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üéØ Smart Study Recommendations</h3>`;
                
                if (studyRecommendations.length > 0) {
                    const sourceText = studyRecommendations[0].recommendation_source === 'recent_study_songs' ? 'Based on your recently played study songs' :
                                     studyRecommendations[0].recommendation_source === 'study_songs' ? 'Based on your study playlist songs' :
                                     studyRecommendations[0].recommendation_source === 'popular_study' ? 'Popular study music worldwide' :
                                     'From curated study playlists';
                    html += `<p style="margin-bottom:1rem;color:#b3b3b3;">${sourceText}</p>`;
                    html += '<div style="max-height:400px;overflow-y:auto;">';
                    studyRecommendations.slice(0, 15).forEach((track, i) => {
                        if (track && track.name) {
                            const artwork = track.album?.images?.[0]?.url || '';
                            html += `<div class="track-item">
                                ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üéµ</div>'}
                                <div class="track-info">
                                    <div class="track-name">${i+1}. ${track.name}${track.explicit ? ' üÖ¥' : ''}</div>
                                    <div class="track-artist">by ${track.artists?.map(a => a.name).join(', ') || 'Unknown'}</div>
                                </div>
                                <div class="track-actions">
                                    <button class="btn btn-primary btn-sm" onclick="playSpotifyTrackId('${track.id}')">‚ñ∂Ô∏è Play</button>
                                    <button class="btn btn-secondary btn-sm" onclick="addSearchTrackToQueue('${track.id}', false)">Queue</button>
                                </div>
                            </div>`;
                        }
                    });
                    html += '</div>';
                } else {
                    html += '<p style="color:#b3b3b3;text-align:center;padding:2rem;">Unable to load study recommendations. Try creating some study playlists first!</p>';
                }
                html += '</div>';
                
                // Recent Study Songs
                if (listeningStats.recentStudySongs && listeningStats.recentStudySongs.length > 0) {
                    html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                        <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üïê Recently Played Study Songs</h3>
                        <p style="margin-bottom:1rem;color:#b3b3b3;">Study songs from your recent listening</p>
                        <div style="max-height:300px;overflow-y:auto;">`;
                    
                    listeningStats.recentStudySongs.slice(0, 10).forEach((track, i) => {
                        const artwork = track.images?.[0]?.url || '';
                        html += `<div class="track-item">
                            ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üéµ</div>'}
                            <div class="track-info">
                                <div class="track-name">${i+1}. ${track.name}</div>
                                <div class="track-artist">by ${track.artists?.join(', ') || 'Unknown'}</div>
                            </div>
                            <div class="track-actions">
                                <button class="btn btn-primary btn-sm" onclick="playSpotifyTrackId('${track.id}')">‚ñ∂Ô∏è Play</button>
                            </div>
                        </div>`;
                    });
                    html += '</div></div>';
                }
                
                // Popular Public Study Playlists
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üìö Popular Study Playlists</h3>
                    <p style="margin-bottom:1rem;color:#b3b3b3;">Curated public study playlists from the community</p>`;
                
                // Get popular study playlists
                try {
                    const popularStudyPlaylists = await makeSpotifyRequest('search', {
                        q: 'study focus lofi',
                        type: 'playlist',
                        limit: 8
                    });
                    
                    if (popularStudyPlaylists && popularStudyPlaylists.playlists && popularStudyPlaylists.playlists.items.length > 0) {
                        html += '<div style="max-height:400px;overflow-y:auto;">';
                        popularStudyPlaylists.playlists.items.forEach((playlist, i) => {
                            if (!playlist) return;
                            const artwork = playlist.images?.[0]?.url || '';
                            html += `<div class="track-item" onclick="showSpotifyPlaylistApp('${playlist.id}','${playlist.name.replace(/'/g, "&#39;")}')" style="cursor:pointer;">
                                ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üìö</div>'}
                                <div class="track-info">
                                    <div class="track-name">${i+1}. ${playlist.name}</div>
                                    <div class="track-artist">üéµ ${playlist.tracks?.total || 0} tracks ‚Ä¢ by ${playlist.owner?.display_name || 'Community'}</div>
                                </div>
                                <div class="track-actions">
                                    <button class="btn btn-primary" onclick="event.stopPropagation(); playEntirePlaylist('${playlist.id}')" title="Play playlist">‚ñ∂Ô∏è Play</button>
                                </div>
                            </div>`;
                        });
                        html += '</div>';
                    } else {
                        html += '<p style="color:#b3b3b3;text-align:center;padding:2rem;">Unable to load popular study playlists right now.</p>';
                    }
                } catch (error) {
                    console.error('Error loading popular study playlists:', error);
                    html += '<p style="color:#b3b3b3;text-align:center;padding:2rem;">Unable to load popular study playlists right now.</p>';
                }
                html += '</div>';

                // Study Radio Stations (curated suggestions)
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üìª Study Radio Stations</h3>
                    <p style="margin-bottom:1rem;color:#b3b3b3;">Curated study radio stations for continuous focus music</p>
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:1rem;">
                        <div style="background:#1c253b;padding:1rem;border-radius:15px;text-align:center;">
                            <h4 style="color:#1db954;margin-bottom:0.5rem;">üéπ Classical Study</h4>
                            <p style="font-size:0.8rem;color:#b3b3b3;margin-bottom:1rem;">Peaceful classical music</p>
                            <button class="btn btn-primary btn-sm" onclick="searchAndPlayGenre('classical instrumental')">‚ñ∂Ô∏è Play</button>
                        </div>
                        <div style="background:#1c253b;padding:1rem;border-radius:15px;text-align:center;">
                            <h4 style="color:#1db954;margin-bottom:0.5rem;">üåô Lo-Fi Hip Hop</h4>
                            <p style="font-size:0.8rem;color:#b3b3b3;margin-bottom:1rem;">Chill beats to study to</p>
                            <button class="btn btn-primary btn-sm" onclick="searchAndPlayGenre('lofi hip hop')">‚ñ∂Ô∏è Play</button>
                        </div>
                        <div style="background:#1c253b;padding:1rem;border-radius:15px;text-align:center;">
                            <h4 style="color:#1db954;margin-bottom:0.5rem;">üåä Ambient Focus</h4>
                            <p style="font-size:0.8rem;color:#b3b3b3;margin-bottom:1rem;">Atmospheric soundscapes</p>
                            <button class="btn btn-primary btn-sm" onclick="searchAndPlayGenre('ambient chill study')">‚ñ∂Ô∏è Play</button>
                        </div>
                        <div style="background:#1c253b;padding:1rem;border-radius:15px;text-align:center;">
                            <h4 style="color:#1db954;margin-bottom:0.5rem;">üéº Piano Study</h4>
                            <p style="font-size:0.8rem;color:#b3b3b3;margin-bottom:1rem;">Peaceful piano melodies</p>
                            <button class="btn btn-primary btn-sm" onclick="searchAndPlayGenre('piano study')">‚ñ∂Ô∏è Play</button>
                        </div>
                    </div>
                </div>`;

                main.innerHTML = html;
            } catch (error) {
                console.error('Error loading study recommendations:', error);
                main.innerHTML = '<div style="text-align:center;padding:2rem;color:#ff6b6b;">Error loading recommendations</div>';
            }
        }

        async function searchAndPlayGenre(query) {
            try {
                const searchResults = await makeSpotifyRequest('search', {
                    q: query,
                    type: 'playlist',
                    limit: 1
                });
                
                if (searchResults.playlists?.items?.[0]) {
                    const playlist = searchResults.playlists.items[0];
                    playEntirePlaylist(playlist.id);
                    showSuccess(`Playing ${playlist.name}!`);
                } else {
                    showError('No playlists found for this genre');
                }
            } catch (error) {
                showError('Failed to search for genre playlists');
            }
        }

        async function searchAndPlayArtist(artistId) {
            try {
                // Get artist's top tracks
                const response = await fetch(`https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=US`, {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.tracks && data.tracks.length > 0) {
                        // Play first track and queue the rest
                        await playSpotifyTrack(data.tracks[0].id);
                        showSuccess(`Playing ${data.tracks[0].name}!`);
                    } else {
                        showError('No tracks found for this artist');
                    }
                } else {
                    showError('Failed to get artist tracks');
                }
            } catch (error) {
                showError('Failed to play artist tracks');
            }
        }

        function updateDashboardCurrentlyPlaying(track, isPlaying) {
            // Only update if we're currently viewing the dashboard
            const nowPlayingSection = Array.from(document.querySelectorAll('#spotify-main h3')).find(h3 => h3.textContent.includes('Now Playing'));
            if (!nowPlayingSection) return; // Dashboard not visible
            
            console.log('üéµ Updating dashboard currently playing:', track?.name, 'playing:', isPlaying);
            
            const container = nowPlayingSection.parentElement;
            
            // Remove all existing content after the h3
            let nextElement = nowPlayingSection.nextElementSibling;
            while (nextElement) {
                const elementToRemove = nextElement;
                nextElement = nextElement.nextElementSibling;
                elementToRemove.remove();
            }
            
            // Add new content
            let nowPlayingHTML = '';
            if (track) {
                const explicitIcon = track.explicit ? ' üÖ¥' : '';
                nowPlayingHTML = `<p><strong>Track:</strong> ${track.name}${explicitIcon}</p>
                    <p><strong>Artist:</strong> ${track.artists.map(a=>a.name).join(', ')}</p>
                    <p><strong>Album:</strong> ${track.album?.name || 'Unknown Album'}</p>
                    <p style="color:#1db954;"><strong>Playing:</strong> ${isPlaying ? '‚ñ∂Ô∏è Yes' : '‚è∏Ô∏è Paused'}</p>`;
            } else {
                nowPlayingHTML = `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px;">
                    <span style="font-size:2rem;margin-bottom:8px;">üéµ</span>
                    <span style="color:#b3b3b3;font-style:italic;">No music currently playing</span>
                </div>`;
            }
            
            container.insertAdjacentHTML('beforeend', nowPlayingHTML);
        }

        function showSpotifyLibrary() {
            const main = document.getElementById('spotify-main');
            main.innerHTML = '<h2>Your Playlists</h2><div id="spotify-app-playlists-list"><span class="loading-spinner"></span> Loading playlists...</div>';
            loadSpotifyPlaylistsApp();
        }

        function showSpotifySearch() {
            const main = document.getElementById('spotify-main');
        }
        async function renderSpotifyHome() {
            const main = document.getElementById('spotify-main');
            try {
                console.log('Loading comprehensive home data...');
                const [profile, nowPlaying, topArtists, listeningStats, playlists] = await Promise.allSettled([
                    makeSpotifyRequest('me'),
                    makeSpotifyRequest('me/player/currently-playing'),
                    makeSpotifyRequest('me/top/artists', { limit: 15 }),
                    getCachedListeningStats(false), // Use full data since it's pre-loaded
                    makeSpotifyRequest('me/playlists', { limit: 20 })
                ]).then(results => results.map(result => result.status === 'fulfilled' ? result.value : { items: [] }));
                
                console.log('‚úÖ Listening stats loaded from cache or calculated fresh');
                console.log('üìä Using cached listening stats for home display');
                console.log('üìä Listening stats result:', listeningStats);
                
                // Get top albums from top tracks in listening stats
                const topAlbums = getTopAlbumsFromTracks(listeningStats.topTracks || []);
                
        let html = '';
                html += `<h2 class="glow-title" style="font-size:2.5rem;margin-bottom:2rem;">üè† Spotify Home</h2>`;
                
                // Top Overview Cards
                html += `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:1.5rem;margin-bottom:2rem;">
                    <!-- Profile Card -->
                    <div style="background:#1c253b;padding:1.5rem;border-radius:20px;box-shadow:0 4px 20px rgba(0,0,0,0.3);">
                        <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üë§ Profile</h3>
                        <p><strong>Name:</strong> ${profile?.display_name || spotifyUserProfile?.display_name || 'N/A'}</p>
                        <p><strong>Email:</strong> <span style="word-break:break-all;word-wrap:break-word;">${profile?.email || spotifyUserProfile?.email || 'N/A'}</span></p>
                        <p><strong>Country:</strong> ${profile?.country || spotifyUserProfile?.country || 'N/A'}</p>
                        <p><strong>Followers:</strong> ${formatNumber(profile?.followers?.total || spotifyUserProfile?.followers?.total || 0)}</p>
                        <p style="color:#1db954;"><strong>Subscription:</strong> ${profile?.product || spotifyUserProfile?.product || 'N/A'}</p>
            </div>
                    
                    <!-- Currently Playing Card -->
                    <div style="background:#1c253b;padding:1.5rem;border-radius:20px;box-shadow:0 4px 20px rgba(0,0,0,0.3);">
                        <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üéµ Now Playing</h3>`;
                        
                if (nowPlaying && nowPlaying.item && !nowPlaying.error) {
                    const explicitIcon = nowPlaying.item.explicit ? ' üÖ¥' : '';
                    html += `<p><strong>Track:</strong> ${nowPlaying.item.name}${explicitIcon}</p>
                <p><strong>Artist:</strong> ${nowPlaying.item.artists.map(a=>a.name).join(', ')}</p>
                <p><strong>Album:</strong> ${nowPlaying.item.album.name}</p>
                <p style="color:#1db954;"><strong>Playing:</strong> ${nowPlaying.is_playing ? '‚ñ∂Ô∏è Yes' : '‚è∏Ô∏è Paused'}</p>`;
        } else {
            html += `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px;">
                <span style="font-size:2rem;margin-bottom:8px;">üéµ</span>
                <span style="color:#b3b3b3;font-style:italic;">No music currently playing</span>
            </div>`;
        }
                html += `</div>
                </div>`;

                // Listening Behavior Patterns
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üìä Listening Behavior Patterns</h3>
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:1rem;margin-bottom:1.5rem;">
                        <div style="background:#1c253b;padding:1rem;border-radius:15px;text-align:center;">
                            <h4 style="color:#1db954;margin-bottom:0.8rem;">üåÖ Morning (6am-12pm)</h4>
                            ${(() => {
                                // Use time-based morning genres from recent listening data
                                const morningGenres = listeningStats.timeBasedGenres?.morning || [];
                                
                                if (morningGenres.length > 0) {
                                    return morningGenres.map((genre, index) => {
                                        const isTop = index === 0;
                                        return `<div style="margin-bottom:0.3rem;font-size:${isTop ? '0.95rem' : '0.85rem'};font-weight:${isTop ? 'bold' : '500'};color:${isTop ? '#1db954' : '#b3b3b3'};">${index + 1}. ${genre.genre} (${genre.percentage}%)</div>`;
                                    }).join('');
                                } else if (listeningStats.topGenres && listeningStats.topGenres.length >= 3) {
                                    // Fallback to overall top genres with note
                                    const top3 = listeningStats.topGenres.slice(0, 3);
                                    const totalTime = top3.reduce((sum, genre) => sum + genre.time, 0);
                                    const genreList = top3.map((genre, index) => {
                                        const percentage = totalTime > 0 ? Math.round((genre.time / totalTime) * 100) : 0;
                                        return `${genre.genre} (${percentage}%)`;
                                    }).join(', ');
                                    return `<p style="font-size:0.85rem;color:#b3b3b3;line-height:1.4;">No morning data yet<br><span style="font-size:0.8rem;opacity:0.7;">Your overall top: ${genreList}</span></p>`;
                                } else {
                                    return `<p style="font-size:0.9rem;color:#b3b3b3;">Listen to music in the morning to see patterns!</p>`;
                                }
                            })()}
                        </div>
                        <div style="background:#1c253b;padding:1rem;border-radius:15px;text-align:center;">
                            <h4 style="color:#1db954;margin-bottom:0.8rem;">üåÜ Daytime (12pm-8pm)</h4>
                            ${(() => {
                                // Use time-based daytime genres from recent listening data
                                const daytimeGenres = listeningStats.timeBasedGenres?.daytime || [];
                                
                                if (daytimeGenres.length > 0) {
                                    return daytimeGenres.map((genre, index) => {
                                        const isTop = index === 0;
                                        return `<div style="margin-bottom:0.3rem;font-size:${isTop ? '0.95rem' : '0.85rem'};font-weight:${isTop ? 'bold' : '500'};color:${isTop ? '#1db954' : '#b3b3b3'};">${index + 1}. ${genre.genre} (${genre.percentage}%)</div>`;
                                    }).join('');
                                } else if (listeningStats.topGenres && listeningStats.topGenres.length >= 3) {
                                    // Fallback to overall top genres with note
                                    const top3 = listeningStats.topGenres.slice(0, 3);
                                    const totalTime = top3.reduce((sum, genre) => sum + genre.time, 0);
                                    const genreList = top3.map((genre, index) => {
                                        const percentage = totalTime > 0 ? Math.round((genre.time / totalTime) * 100) : 0;
                                        return `${genre.genre} (${percentage}%)`;
                                    }).join(', ');
                                    return `<p style="font-size:0.85rem;color:#b3b3b3;line-height:1.4;">No daytime data yet<br><span style="font-size:0.8rem;opacity:0.7;">Your overall top: ${genreList}</span></p>`;
                                } else {
                                    return `<p style="font-size:0.9rem;color:#b3b3b3;">Listen to music during the day to see patterns!</p>`;
                                }
                            })()}
                        </div>
                        <div style="background:#1c253b;padding:1rem;border-radius:15px;text-align:center;">
                            <h4 style="color:#1db954;margin-bottom:0.8rem;">üåô Night (8pm-5am)</h4>
                            ${(() => {
                                // Use time-based night genres from recent listening data
                                const nightGenres = listeningStats.timeBasedGenres?.night || [];
                                
                                if (nightGenres.length > 0) {
                                    return nightGenres.map((genre, index) => {
                                        const isTop = index === 0;
                                        return `<div style="margin-bottom:0.3rem;font-size:${isTop ? '0.95rem' : '0.85rem'};font-weight:${isTop ? 'bold' : '500'};color:${isTop ? '#1db954' : '#b3b3b3'};">${index + 1}. ${genre.genre} (${genre.percentage}%)</div>`;
                                    }).join('');
                                } else if (listeningStats.topGenres && listeningStats.topGenres.length >= 3) {
                                    // Fallback to overall top genres with note
                                    const top3 = listeningStats.topGenres.slice(0, 3);
                                    const totalTime = top3.reduce((sum, genre) => sum + genre.time, 0);
                                    const genreList = top3.map((genre, index) => {
                                        const percentage = totalTime > 0 ? Math.round((genre.time / totalTime) * 100) : 0;
                                        return `${genre.genre} (${percentage}%)`;
                                    }).join(', ');
                                    return `<p style="font-size:0.85rem;color:#b3b3b3;line-height:1.4;">No night data yet<br><span style="font-size:0.8rem;opacity:0.7;">Your overall top: ${genreList}</span></p>`;
                                } else {
                                    return `<p style="font-size:0.9rem;color:#b3b3b3;">Listen to music at night to see patterns!</p>`;
                                }
                            })()}
                        </div>
                        <div style="background:#1c253b;padding:1rem;border-radius:15px;text-align:center;">
                            <h4 style="color:#1db954;margin-bottom:0.8rem;">üìö Study Mode</h4>
                            ${(() => {
                                // Use study genres from playlists
                                const studyGenres = listeningStats.timeBasedGenres?.study || [];
                                
                                if (studyGenres.length > 0) {
                                    return studyGenres.map((genre, index) => {
                                        const isTop = index === 0;
                                        return `<div style="margin-bottom:0.3rem;font-size:${isTop ? '0.95rem' : '0.85rem'};font-weight:${isTop ? 'bold' : '500'};color:${isTop ? '#1db954' : '#b3b3b3'};">${index + 1}. ${genre.genre} (${genre.percentage}%)</div>`;
                                    }).join('');
                                } else {
                                    return `<p style="font-size:0.9rem;color:#b3b3b3;">No study music detected recently.<br><span style="font-size:0.8rem;opacity:0.7;">Listen to lo-fi, ambient, or focus music to see your study patterns!</span></p>`;
                                }
                            })()}
                        </div>
                    </div>
                    
                    <!-- Top 5 Genres -->
                    ${listeningStats.topGenres && listeningStats.topGenres.length > 0 ? `
                        <div style="background:#1c253b;padding:1.5rem;border-radius:15px;">
                            <h4 style="color:#1db954;margin-bottom:1rem;text-align:center;">üé≠ Top 5 Genres</h4>
                            <div style="max-height:200px;overflow-y:auto;">
                                ${(() => {
                                    const top5 = listeningStats.topGenres.slice(0, 5);
                                    const totalTime = top5.reduce((sum, genre) => sum + genre.time, 0);
                                    return top5.map((genreData, index) => {
                                        const isTop = index === 0;
                                        const percentage = totalTime > 0 ? Math.round((genreData.time / totalTime) * 100) : 0;
                                        return `<div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem;margin-bottom:0.5rem;background:${isTop ? 'linear-gradient(45deg, #1db954, #1ed760)' : '#162133'};border-radius:8px;${isTop ? 'transform:scale(1.02);box-shadow:0 2px 8px rgba(29,185,84,0.3);' : ''}">
                                            <span style="font-weight:${isTop ? 'bold' : '500'};color:${isTop ? '#000' : '#fff'};${isTop ? 'text-shadow:none;' : ''}">${index + 1}. ${genreData.genre}</span>
                                            <span style="font-weight:bold;color:${isTop ? '#000' : '#1db954'};">${percentage}%</span>
                                        </div>`;
                                    }).join('');
                                })()}
                            </div>
                        </div>
                    ` : ''}
                </div>`;

                // Recently Played
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üïê Recently Played</h3>
                    <div style="max-height:300px;overflow-y:auto;">`;
                if (listeningStats.recentTracks && listeningStats.recentTracks.length > 0) {
                    listeningStats.recentTracks.slice(0, 10).forEach((item, i) => {
                        const track = item.track;
                        if (track) {
                            const artwork = track.album?.images?.[0]?.url || '';
                            html += `<div class="track-item">
                                ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üéµ</div>'}
                                <div class="track-info">
                                    <div class="track-name">${track.name}${track.explicit ? ' üÖ¥' : ''}</div>
                                    <div class="track-artist">by ${track.artists?.map(a => a.name).join(', ') || 'Unknown'}</div>
                                </div>
                                <div class="track-actions">
                                    <button class="btn btn-primary btn-sm" onclick="playSpotifyTrack('${track.id}')">‚ñ∂Ô∏è Play</button>
                                </div>
                            </div>`;
                        }
                    });
                } else {
                    html += '<p style="color:#b3b3b3;text-align:center;">No recent tracks found.</p>';
                }
                html += '</div></div>';

                // Top Tracks
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üéµ Your Top Songs</h3>
                    <div style="max-height:400px;overflow-y:auto;">`;
                if (listeningStats.topTracks && listeningStats.topTracks.length > 0) {
                    window.currentTopTracks = listeningStats.topTracks;
                    listeningStats.topTracks.forEach((track, i) => {
                const artwork = track.album.images[0]?.url || '';
                        html += `<div class="track-item">
                        ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üéµ</div>'}
                        <div class="track-info">
                                <div class="track-name">${i+1}. ${track.name}${track.explicit ? ' üÖ¥' : ''}</div>
                            <div class="track-artist">by ${track.artists.map(a=>a.name).join(', ')}</div>
                        </div>
                        <div class="track-actions">
                                <button class="btn btn-primary btn-sm" onclick="playFromTopTracks(${i})">‚ñ∂Ô∏è Play</button>
                                <button class="btn btn-secondary btn-sm" onclick="addToQueueFromTopTracks(${i}, false)">Queue</button>
                        </div>
                        </div>`;
                    });
                } else {
                    html += '<p style="color:#b3b3b3;text-align:center;">No top tracks found.</p>';
                }
                html += '</div></div>';

                // Top Artists
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üé§ Your Top Artists</h3>
                    <div style="max-height:400px;overflow-y:auto;">`;
                if (topArtists && topArtists.items && topArtists.items.length > 0) {
                    topArtists.items.forEach((artist, i) => {
                        const artwork = artist.images?.[0]?.url || '';
                        html += `<div class="track-item">
                            ${artwork ? `<img src="${artwork}" class="track-artwork" style="border-radius:50%;">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;border-radius:50%;">üé§</div>'}
                            <div class="track-info">
                                <div class="track-name">${i+1}. ${artist.name}</div>
                                <div class="track-artist">${formatNumber(artist.followers?.total || 0)} followers ‚Ä¢ ${artist.genres?.slice(0,2).join(', ') || 'Various genres'}</div>
                    </div>
                            <div class="track-actions">
                                <button class="btn btn-primary btn-sm" onclick="searchAndPlayArtist('${artist.id}')">‚ñ∂Ô∏è Play</button>
                            </div>
                        </div>`;
            });
        } else {
                    html += '<p style="color:#b3b3b3;text-align:center;">No top artists found.</p>';
                }
                html += '</div></div>';

                // Top Albums
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üíø Your Top Albums</h3>
                    <div style="max-height:400px;overflow-y:auto;">`;
                if (topAlbums.length > 0) {
                    topAlbums.forEach((album, i) => {
                        const artwork = album.images?.[0]?.url || '';
                        html += `<div class="track-item">
                            ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üíø</div>'}
                            <div class="track-info">
                                <div class="track-name">${i+1}. ${album.name}</div>
                                <div class="track-artist">by ${album.artists?.map(a => a.name).join(', ') || 'Unknown'} ‚Ä¢ ${album.total_tracks || 0} tracks</div>
                            </div>
                            <div class="track-actions">
                                <button class="btn btn-primary btn-sm" onclick="playSpotifyAlbum('${album.id}')">‚ñ∂Ô∏è Play</button>
                            </div>
                        </div>`;
                    });
                } else {
                    html += '<p style="color:#b3b3b3;text-align:center;">No albums found from your top tracks.</p>';
                }
                html += '</div></div>';

                // Top Playlists
                html += `<div style="background:#1e2a45;padding:1.5rem;border-radius:20px;margin-bottom:2rem;">
                    <h3 style="font-size:1.3rem;font-weight:600;margin-bottom:1rem;color:#1db954;">üìö Your Top Playlists</h3>
                    <div style="max-height:400px;overflow-y:auto;">`;
                if (playlists && playlists.items && playlists.items.length > 0) {
            playlists.items.forEach((pl, i) => {
                        if (!pl || !pl.id) return; // Skip invalid playlists
                        const artwork = pl.images && pl.images.length > 0 ? pl.images[0].url : '';
                        const trackCount = pl.tracks && pl.tracks.total ? pl.tracks.total : 0;
                        const ownerName = pl.owner && pl.owner.display_name ? pl.owner.display_name : 'Unknown';
                        html += `<div class="track-item" onclick="showSpotifyPlaylistApp('${pl.id}','${pl.name.replace(/'/g, "&#39;")}')" style="cursor:pointer;">
                        ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üìö</div>'}
                        <div class="track-info">
                            <div class="track-name">${i+1}. ${pl.name}</div>
                                <div class="track-artist">üéµ ${trackCount} tracks ‚Ä¢ By ${ownerName}</div>
                        </div>
                        <div class="track-actions">
                                <button class="btn btn-primary" onclick="event.stopPropagation(); playEntirePlaylist('${pl.id}')">‚ñ∂Ô∏è Play</button>
                        </div>
                        </div>`;
            });
        } else {
                    html += '<p style="color:#b3b3b3;text-align:center;">No playlists found.</p>';
        }
                html += '</div></div>';

        main.innerHTML = html;
                console.log('Home page rendered successfully with all sections');
                
                // Initialize dashboard with current player state if available
                if (spotifyCurrentTrack) {
                    updateDashboardCurrentlyPlaying(spotifyCurrentTrack, spotifyIsPlaying);
                }
    } catch (error) {
                console.error('Error loading home:', error);
        main.innerHTML = `
                    <h2 class="glow-title">üè† Spotify Home</h2>
            <div class="error">
                        <h3>Failed to load home page</h3>
                <p>Error: ${error.message}</p>
                        <button class="btn btn-primary" onclick="renderSpotifyHome()">Try Again</button>
            </div>
        `;
    }
}
        async function loadSpotifyPlaylistsApp() {
    const listDiv = document.getElementById('spotify-app-playlists-list');
    try {
        console.log('Loading playlists...');
        const response = await fetch('https://api.spotify.com/v1/me/playlists?limit=50', {
            headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        console.log('Playlists loaded:', data.items?.length);
        console.log('Sample playlist data:', data.items?.[0]); // Debug first playlist
        if (!data.items || data.items.length === 0) {
            listDiv.innerHTML = '<p>No playlists found.</p>';
            return;
        }
        let html = '<div class="playlist-grid">';
        data.items.forEach((pl, index) => {
            try {
                if (!pl || !pl.id) {
                    console.warn('Skipping invalid playlist at index:', index, pl);
                    return;
                }
                
                const artwork = pl.images && pl.images.length > 0 ? pl.images[0].url : '';
                const trackCount = pl.tracks && pl.tracks.total ? pl.tracks.total : 0;
                const playlistName = pl.name || 'Unnamed Playlist';
                const playlistId = pl.id;
                
            html += `
                    <div class="playlist-card" onclick="showSpotifyPlaylistApp('${playlistId}','${playlistName.replace(/'/g, "&#39;")}')">
                    ${artwork ? 
                        `<img src="${artwork}" class="playlist-artwork">` : 
                        '<div class="no-image">üìö</div>'
                    }
                        <div class="playlist-name">${playlistName}</div>
                        <div class="playlist-tracks">${trackCount} tracks</div>
                        <div style="display:flex;flex-direction:column;gap:0.5rem;margin-top:0.5rem;">
                            <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); playEntirePlaylist('${playlistId}')" title="Play first song and queue the rest">‚ñ∂Ô∏è Play</button>
                            <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); addPlaylistToQueue('${playlistId}', false)" style="min-width: 60px;">Queue</button>
                            <button class="btn btn-warning btn-sm" onclick="event.stopPropagation(); addPlaylistToQueue('${playlistId}', true)" style="min-width: 80px;">Play Next</button>
                        </div>
                </div>
            `;
            } catch (error) {
                console.error('Error processing playlist at index:', index, error, pl);
                // Continue with next playlist instead of breaking the entire list
            }
        });
        html += '</div>';
        listDiv.innerHTML = html;
    } catch (error) {
        console.error('Error loading playlists:', error);
        listDiv.innerHTML = `
            <div class="error">
                <h3>Failed to load playlists</h3>
                <p>Error: ${error.message}</p>
                <button class="btn btn-primary" onclick="loadSpotifyPlaylistsApp()">Try Again</button>
            </div>
        `;
    }
}
        async function showSpotifyPlaylistApp(playlistId, playlistName) {
    const main = document.getElementById('spotify-main');
    main.innerHTML = `
        <div style="display:flex;align-items:center;gap:1rem;margin-bottom:2rem;">
            <button class="btn btn-secondary" onclick="showSpotifyLibrary()">‚Üê Back to Playlists</button>
            <h2>${playlistName}</h2>
        </div>
        <div id="spotify-app-playlist-tracks"><span class="loading-spinner"></span> Loading tracks...</div>
    `;
    try {
        console.log('Loading playlist tracks for:', playlistId);
        const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`, {
            headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        console.log('Playlist tracks loaded:', data.items?.length);
        const tracksDiv = document.getElementById('spotify-app-playlist-tracks');
        if (!data.items || data.items.length === 0) {
            tracksDiv.innerHTML = '<p>No tracks found in this playlist.</p>';
            return;
        }
        // Store playlist tracks for custom queue
        const playlistTracks = data.items.filter(item => item.track).map(item => item.track);
        window.currentPlaylistTracks = playlistTracks;
        window.currentPlaylistId = playlistId;
        
        let html = `
            <div style="margin-bottom:1rem;">
                <button class="btn btn-primary" onclick="playSpotifyPlaylistId('${playlistId}')" ${!spotifyIsPremium || !spotifyPlayerReady ? 'disabled' : ''}>‚ñ∂Ô∏è Play All</button>
                <button class="btn btn-info" onclick="playCustomPlaylistShuffle('${playlistId}')" title="Play with shuffled queue">üîÄ Shuffle Play</button>
            </div>
            <div style="max-height:60vh;overflow-y:auto;">
        `;
        data.items.forEach((item, index) => {
            if (!item.track) return; // Skip if track is null
            const track = item.track;
            const artwork = track.album?.images[0]?.url || '';
            html += `
                <div class="track-item">
                    ${artwork ? 
                        `<img src="${artwork}" class="track-artwork">` : 
                        '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üéµ</div>'
                    }
                    <div style="width:30px;text-align:center;opacity:0.7;">${index + 1}</div>
                    <div class="track-info">
                        <div class="track-name">${track.name}${track.explicit ? ' üÖ¥' : ''}</div>
                        <div class="track-artist">by ${track.artists?.map(a=>a.name).join(', ') || 'Unknown Artist'}</div>
                    </div>
                    <div class="track-actions">
                        <button class="btn btn-primary" onclick="playFromPlaylist(${index})">‚ñ∂Ô∏è Play</button>
                        <button class="btn btn-secondary" onclick="addToQueueFromPlaylist(${index}, false)" style="min-width: 60px;">Queue</button>
                        <button class="btn btn-warning" onclick="addToQueueFromPlaylist(${index}, true)" style="min-width: 80px;">Play Next</button>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        tracksDiv.innerHTML = html;
    } catch (error) {
        console.error('Error loading playlist tracks:', error);
        const tracksDiv = document.getElementById('spotify-app-playlist-tracks');
        if (tracksDiv) {
            tracksDiv.innerHTML = `
                <div class="error">
                    <h3>Failed to load tracks</h3>
                    <p>Error: ${error.message}</p>
                    <button class="btn btn-primary" onclick="showSpotifyPlaylistApp('${playlistId}','${playlistName}')">Try Again</button>
                </div>
            `;
        }
    }
}
        async function playSpotifyTrackId(trackId) {
    if (!spotifyAccessToken) {
        showError('Not connected to Spotify');
        return;
    }
    if (spotifyIsPremium && spotifyPlayerReady && spotifyDeviceId) {
        try {
            const response = await fetch('https://api.spotify.com/v1/me/player/play?device_id=' + spotifyDeviceId, {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer ' + spotifyAccessToken,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ uris: ['spotify:track:' + trackId] })
            });
            if (response.ok || response.status === 204) {
                showSuccess('Playing track in Spotify!');
                setTimeout(() => {
                    updateSpotifyPlayerBar();
                }, 1000);
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
        } catch (error) {
            console.error('Playback error:', error);
            playSpotifyPreview(trackId);
        }
    } else {
        playSpotifyPreview(trackId);
    }
}
        async function playSpotifyPreview(trackId) {
    try {
        console.log('Playing preview for track:', trackId);
        const response = await fetch('https://api.spotify.com/v1/tracks/' + trackId, {
            headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        console.log('Track data:', data);
        if (data.preview_url) {
            const audio = new Audio(data.preview_url);
            audio.play();
            showInfo('Playing 30s preview. Upgrade to Premium for full playback.');
        } else {
            showError('No preview available for this track.');
        }
    } catch (error) {
        console.error('Preview error:', error);
        showError('Failed to play preview: ' + error.message);
    }
}
        async function playSpotifyPlaylistId(playlistId) {
    if (!spotifyAccessToken || !spotifyIsPremium || !spotifyPlayerReady || !spotifyDeviceId) {
        showError('Premium account and active device required for playlist playback');
        return;
    }
    try {
        console.log('Playing playlist:', playlistId);
        const response = await fetch('https://api.spotify.com/v1/me/player/play?device_id=' + spotifyDeviceId, {
            method: 'PUT',
            headers: {
                'Authorization': 'Bearer ' + spotifyAccessToken,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ context_uri: 'spotify:playlist:' + playlistId })
        });
        if (response.ok || response.status === 204) {
            showSuccess('Playing playlist in Spotify!');
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        console.error('Playlist playback error:', error);
        showError('Failed to play playlist: ' + error.message);
    }
}
        async function shuffleSpotifyPlaylist(playlistId) {
    if (!spotifyAccessToken || !spotifyIsPremium || !spotifyPlayerReady || !spotifyDeviceId) {
        showError('Premium account and active device required for shuffle playback');
        return;
    }
    try {
        // Enable shuffle
        await fetch('https://api.spotify.com/v1/me/player/shuffle?state=true&device_id=' + spotifyDeviceId, {
            method: 'PUT',
            headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
        });
        // Play playlist
        const response = await fetch('https://api.spotify.com/v1/me/player/play?device_id=' + spotifyDeviceId, {
            method: 'PUT',
            headers: {
                'Authorization': 'Bearer ' + spotifyAccessToken,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ context_uri: 'spotify:playlist:' + playlistId })
        });
        if (response.ok || response.status === 204) {
            showSuccess('Playing playlist on shuffle!');
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        console.error('Shuffle playback error:', error);
        showError('Failed to shuffle playlist: ' + error.message);
    }
}
        async function queueSpotifyTrack(trackId) {
    if (!spotifyAccessToken || !spotifyIsPremium || !spotifyPlayerReady || !spotifyDeviceId) {
        showError('Premium account and active device required for queue');
        return;
    }
    try {
        const response = await fetch('https://api.spotify.com/v1/me/player/queue?uri=spotify:track:' + trackId + '&device_id=' + spotifyDeviceId, {
            method: 'POST',
            headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
        });
        if (response.ok || response.status === 204) {
            showSuccess('Track added to queue!');
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        console.error('Queue error:', error);
        showError('Failed to add to queue: ' + error.message);
    }
}

        // Custom Queue Management Functions
        function createCustomQueue(tracks, source, startIndex = 0, shuffle = false) {
            console.log('üéµ Creating custom queue with:', tracks.length, 'tracks from', source);
            console.log('üéµ Start index:', startIndex, 'Shuffle:', shuffle);
            
            spotifyOriginalList = [...tracks];
            spotifyCurrentSource = source;
            
            if (shuffle) {
                // Shuffle all tracks except the first one (currently playing)
                const currentTrack = tracks[startIndex];
                const otherTracks = tracks.filter((_, i) => i !== startIndex);
                
                // Fisher-Yates shuffle
                for (let i = otherTracks.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [otherTracks[i], otherTracks[j]] = [otherTracks[j], otherTracks[i]];
                }
                
                spotifyCustomQueue = [currentTrack, ...otherTracks];
                spotifyQueueIndex = 0;
            } else {
                spotifyCustomQueue = [...tracks];
                spotifyQueueIndex = startIndex;
            }
            
            spotifyQueueEnabled = true;
            console.log(`‚úÖ Custom queue created with ${spotifyCustomQueue.length} tracks from ${source}`);
            console.log('üéµ Queue enabled:', spotifyQueueEnabled, 'Current index:', spotifyQueueIndex);
        }

        function addToCustomQueue(track, playNext = false) {
            if (!spotifyQueueEnabled) {
                spotifyCustomQueue = [];
                spotifyQueueIndex = 0;
                spotifyQueueEnabled = true;
            }
            
            if (playNext) {
                // Insert after current track
                spotifyCustomQueue.splice(spotifyQueueIndex + 1, 0, track);
                showSuccess(`"${track.name}" will play next!`);
            } else {
                // Add to end of queue
                spotifyCustomQueue.push(track);
                showSuccess(`"${track.name}" added to queue!`);
            }
            
            console.log(`Track added to custom queue. Queue now has ${spotifyCustomQueue.length} tracks`);
        }

        function playFromCustomQueue(trackIndex) {
            console.log('üéµ playFromCustomQueue called with index:', trackIndex);
            console.log('üéµ Current custom queue:', spotifyCustomQueue);
            console.log('üéµ Queue enabled:', spotifyQueueEnabled);
            
            if (!spotifyCustomQueue.length || trackIndex >= spotifyCustomQueue.length) {
                console.log('‚ùå No queue or invalid index');
                return;
            }
            
            spotifyQueueIndex = trackIndex;
            const track = spotifyCustomQueue[trackIndex];
            
            console.log('üéµ Playing track from queue:', track?.name, 'by', track?.artists?.[0]?.name);
            
            if (track && track.id) {
                playSpotifyTrackId(track.id);
            }
        }

        function customSpotifyNext() {
            console.log('üéµ customSpotifyNext called');
            console.log('üéµ Queue enabled:', spotifyQueueEnabled, 'Queue length:', spotifyCustomQueue.length);
            console.log('üéµ Current index:', spotifyQueueIndex);
            
            if (spotifyQueueEnabled && spotifyCustomQueue.length > 0) {
                if (spotifyQueueIndex < spotifyCustomQueue.length - 1) {
                    spotifyQueueIndex++;
                    console.log('üéµ Advancing to next track, new index:', spotifyQueueIndex);
                    playFromCustomQueue(spotifyQueueIndex);
                    return true;
                } else {
                    // End of queue - disable custom queue
                    console.log('üéµ End of queue reached');
                    spotifyQueueEnabled = false;
                    showError('End of queue reached');
                    return false;
                }
            }
            console.log('üéµ Custom queue not active, falling back to Spotify');
            return false;
        }

        function customSpotifyPrev() {
            if (spotifyQueueEnabled && spotifyCustomQueue.length > 0) {
                if (spotifyQueueIndex > 0) {
                    spotifyQueueIndex--;
                    playFromCustomQueue(spotifyQueueIndex);
                    return true;
                }
            }
            return false;
        }

        function clearCustomQueue() {
            spotifyCustomQueue = [];
            spotifyQueueIndex = 0;
            spotifyQueueEnabled = false;
            spotifyCurrentSource = null;
            spotifyOriginalList = [];
            console.log('Custom queue cleared');
        }

        // Playlist-specific queue functions
        function playFromPlaylist(trackIndex) {
            if (!window.currentPlaylistTracks || !window.currentPlaylistTracks[trackIndex]) {
                showError('Track not found in playlist');
                return;
            }
            
            const tracks = window.currentPlaylistTracks;
            createCustomQueue(tracks, `playlist-${window.currentPlaylistId}`, trackIndex, false);
            playFromCustomQueue(trackIndex);
        }

        function playCustomPlaylistShuffle(playlistId) {
            if (!window.currentPlaylistTracks || window.currentPlaylistTracks.length === 0) {
                showError('No tracks found in playlist');
                return;
            }
            
            const tracks = window.currentPlaylistTracks;
            // Start with a random track instead of always the first one
            const randomStartIndex = Math.floor(Math.random() * tracks.length);
            createCustomQueue(tracks, `playlist-${playlistId}`, randomStartIndex, true);
            playFromCustomQueue(0); // Play the first track in the shuffled queue
        }

        function addToQueueFromPlaylist(trackIndex, playNext = false) {
            if (!window.currentPlaylistTracks || !window.currentPlaylistTracks[trackIndex]) {
                showError('Track not found in playlist');
                return;
            }
            
            const track = window.currentPlaylistTracks[trackIndex];
            addToCustomQueue(track, playNext);
        }

        // Top tracks queue functions
        function playFromTopTracks(trackIndex) {
            if (!window.currentTopTracks || !window.currentTopTracks[trackIndex]) {
                showError('Track not found in top tracks');
                return;
            }
            
            const tracks = window.currentTopTracks;
            createCustomQueue(tracks, 'top-tracks', trackIndex, false);
            playFromCustomQueue(trackIndex);
        }

        function addToQueueFromTopTracks(trackIndex, playNext = false) {
            if (!window.currentTopTracks || !window.currentTopTracks[trackIndex]) {
                showError('Track not found in top tracks');
                return;
            }
            
            const track = window.currentTopTracks[trackIndex];
            addToCustomQueue(track, playNext);
        }

        // Search track queue function
        async function addSearchTrackToQueue(trackId, playNext = false) {
            try {
                const response = await fetch(`https://api.spotify.com/v1/tracks/${trackId}`, {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const track = await response.json();
                addToCustomQueue(track, playNext);
            } catch (error) {
                console.error('Error fetching track for queue:', error);
                showError('Failed to add track to queue');
            }
        }

        // Play entire playlist function - plays first song and queues the rest
        async function playEntirePlaylist(playlistId) {
            try {
                const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`, {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const tracks = data.items.filter(item => item.track).map(item => item.track);
                
                if (tracks.length === 0) {
                    showError('No tracks found in playlist');
                    return;
                }
                
                // Create custom queue with entire playlist and start from first track
                createCustomQueue(tracks, `playlist-${playlistId}`, 0, false);
                playFromCustomQueue(0);
                
                showSuccess(`Playing playlist! (${tracks.length} tracks queued)`);
            } catch (error) {
                console.error('Error playing playlist:', error);
                showError('Failed to play playlist');
            }
        }

        // Playlist queue function
        async function addPlaylistToQueue(playlistId, playNext = false) {
            try {
                const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`, {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const tracks = data.items.filter(item => item.track).map(item => item.track);
                
                if (tracks.length === 0) {
                    showError('No tracks found in playlist');
                    return;
                }
                
                if (playNext) {
                    // Add all tracks to play next (reverse order so first track plays first)
                    for (let i = tracks.length - 1; i >= 0; i--) {
                        addToCustomQueue(tracks[i], true);
                    }
                    showSuccess(`Playlist queued to play next! (${tracks.length} tracks)`);
                } else {
                    // Add all tracks to end of queue
                    tracks.forEach(track => addToCustomQueue(track, false));
                    showSuccess(`Playlist added to queue! (${tracks.length} tracks)`);
                }
            } catch (error) {
                console.error('Error fetching playlist for queue:', error);
                showError('Failed to add playlist to queue');
            }
        }

        // Album view function
        async function showSpotifyAlbumApp(albumId, albumName) {
            const main = document.getElementById('spotify-main');
            main.innerHTML = `
                <div style="display:flex;align-items:center;gap:1rem;margin-bottom:2rem;">
                    <button class="btn btn-secondary" onclick="activateSpotifyTab('search')">‚Üê Back to Search</button>
                    <h2>üíø ${albumName}</h2>
                </div>
                <div id="spotify-app-album-tracks"><span class="loading-spinner"></span> Loading album...</div>
            `;
            
            try {
                console.log('Loading album tracks for:', albumId);
                const response = await fetch(`https://api.spotify.com/v1/albums/${albumId}/tracks?limit=50`, {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                // Also get album info for artwork
                const albumResponse = await fetch(`https://api.spotify.com/v1/albums/${albumId}`, {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                const albumInfo = albumResponse.ok ? await albumResponse.json() : null;
                
                console.log('Album tracks loaded:', data.items?.length);
                const tracksDiv = document.getElementById('spotify-app-album-tracks');
                
                if (!data.items || data.items.length === 0) {
                    tracksDiv.innerHTML = '<p>No tracks found in this album.</p>';
                    return;
                }
                
                // Store album tracks for custom queue
                window.currentAlbumTracks = data.items;
                window.currentAlbumId = albumId;
                
                let html = `
                    <div style="margin-bottom:1rem;">
                        <button class="btn btn-primary" onclick="playSpotifyAlbum('${albumId}')" ${!spotifyIsPremium || !spotifyPlayerReady ? 'disabled' : ''}>‚ñ∂Ô∏è Play Album</button>
                        <button class="btn btn-info" onclick="playCustomAlbumShuffle('${albumId}')" title="Play with shuffled queue">üîÄ Shuffle Album</button>
                        <button class="btn btn-secondary" onclick="addAlbumToQueue('${albumId}', false)" style="min-width: 80px;">Queue Album</button>
                    </div>
                    <div style="max-height:60vh;overflow-y:auto;">
                `;
                
                data.items.forEach((track, index) => {
                    const artwork = albumInfo?.images?.[0]?.url || '';
                    html += `
                        <div class="track-item">
                            ${artwork ? 
                                `<img src="${artwork}" class="track-artwork">` : 
                                '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üéµ</div>'
                            }
                            <div style="width:30px;text-align:center;opacity:0.7;">${index + 1}</div>
                            <div class="track-info">
                                <div class="track-name">${track.name}${track.explicit ? ' üÖ¥' : ''}</div>
                                <div class="track-artist">by ${track.artists?.map(a=>a.name).join(', ') || 'Unknown Artist'}</div>
                            </div>
                            <div class="track-actions">
                                <button class="btn btn-primary" onclick="playFromAlbum(${index})">‚ñ∂Ô∏è Play</button>
                                <button class="btn btn-secondary" onclick="addToQueueFromAlbum(${index}, false)" style="min-width: 60px;">Queue</button>
                                <button class="btn btn-warning" onclick="addToQueueFromAlbum(${index}, true)" style="min-width: 80px;">Play Next</button>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                tracksDiv.innerHTML = html;
            } catch (error) {
                console.error('Error loading album tracks:', error);
                const tracksDiv = document.getElementById('spotify-app-album-tracks');
                if (tracksDiv) {
                    tracksDiv.innerHTML = '<p style="color:#ff6b6b;">‚ùå Failed to load album tracks. Please try again.</p>';
                }
                showError('Failed to load album: ' + error.message);
            }
        }

        // Album-specific queue functions
        function playFromAlbum(trackIndex) {
            if (!window.currentAlbumTracks || !window.currentAlbumTracks[trackIndex]) {
                showError('Track not found in album');
                return;
            }
            
            const tracks = window.currentAlbumTracks;
            createCustomQueue(tracks, `album-${window.currentAlbumId}`, trackIndex, false);
            playFromCustomQueue(trackIndex);
        }

        function playCustomAlbumShuffle(albumId) {
            if (!window.currentAlbumTracks || window.currentAlbumTracks.length === 0) {
                showError('No tracks found in album');
                return;
            }
            
            const tracks = window.currentAlbumTracks;
            // Start with a random track instead of always the first one
            const randomStartIndex = Math.floor(Math.random() * tracks.length);
            createCustomQueue(tracks, `album-${albumId}`, randomStartIndex, true);
            playFromCustomQueue(0); // Play the first track in the shuffled queue
        }

        function addToQueueFromAlbum(trackIndex, playNext = false) {
            if (!window.currentAlbumTracks || !window.currentAlbumTracks[trackIndex]) {
                showError('Track not found in album');
                return;
            }
            
            const track = window.currentAlbumTracks[trackIndex];
            addToCustomQueue(track, playNext);
        }

        // Album queue function
        async function addAlbumToQueue(albumId, playNext = false) {
            try {
                const response = await fetch(`https://api.spotify.com/v1/albums/${albumId}/tracks?limit=50`, {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const tracks = data.items;
                
                if (tracks.length === 0) {
                    showError('No tracks found in album');
                    return;
                }
                
                if (playNext) {
                    // Add all tracks to play next (reverse order so first track plays first)
                    for (let i = tracks.length - 1; i >= 0; i--) {
                        addToCustomQueue(tracks[i], true);
                    }
                    showSuccess(`Album queued to play next! (${tracks.length} tracks)`);
                } else {
                    // Add all tracks to end of queue
                    tracks.forEach(track => addToCustomQueue(track, false));
                    showSuccess(`Album added to queue! (${tracks.length} tracks)`);
                }
            } catch (error) {
                console.error('Error fetching album for queue:', error);
                showError('Failed to add album to queue');
            }
        }

        // Artist view function
        async function showSpotifyArtistApp(artistId, artistName) {
            const main = document.getElementById('spotify-main');
            main.innerHTML = `
                <div style="display:flex;align-items:center;gap:1rem;margin-bottom:2rem;">
                    <button class="btn btn-secondary" onclick="activateSpotifyTab('search')">‚Üê Back to Search</button>
                    <h2>üé§ ${artistName}</h2>
                </div>
                <div id="spotify-app-artist-content"><span class="loading-spinner"></span> Loading artist...</div>
            `;
            
            try {
                console.log('Loading artist content for:', artistId);
                
                // Fetch artist's top tracks and albums
                const [topTracksResponse, albumsResponse] = await Promise.all([
                    fetch(`https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=US`, {
                        headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                    }),
                    fetch(`https://api.spotify.com/v1/artists/${artistId}/albums?include_groups=album,single&market=US&limit=20`, {
                        headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                    })
                ]);
                
                if (!topTracksResponse.ok || !albumsResponse.ok) {
                    throw new Error('Failed to fetch artist data');
                }
                
                const topTracksData = await topTracksResponse.json();
                const albumsData = await albumsResponse.json();
                
                // Store artist tracks for custom queue
                window.currentArtistTracks = topTracksData.tracks || [];
                window.currentArtistId = artistId;
                
                console.log('Artist data loaded - tracks:', topTracksData.tracks?.length, 'albums:', albumsData.items?.length);
                const contentDiv = document.getElementById('spotify-app-artist-content');
                
                let html = '';
                
                // Top Tracks Section
                if (topTracksData.tracks && topTracksData.tracks.length > 0) {
                    html += `
                        <div style="background:#1e2a45;padding:1.5rem;border-radius:20px;box-shadow:0 4px 20px rgba(0,0,0,0.2);margin-bottom:2rem;">
                            <h3 style="font-size:1.1rem;font-weight:600;margin-bottom:1rem;">üéµ Top Tracks</h3>
                            <div style="margin-bottom:1rem;">
                                <button class="btn btn-primary" onclick="playFromArtistTracks(0)">‚ñ∂Ô∏è Play Top Tracks</button>
                                <button class="btn btn-info" onclick="playArtistTracksShuffled()" title="Play with shuffled queue">üîÄ Shuffle Top Tracks</button>
                            </div>
                            <div style="max-height:400px;overflow-y:auto;">
                    `;
                    
                    topTracksData.tracks.forEach((track, i) => {
                        const artwork = track.album?.images?.[0]?.url || '';
                        html += `
                            <div class="track-item">
                                ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üéµ</div>'}
                                <div class="track-info">
                                    <div class="track-name">${i+1}. ${track.name}${track.explicit ? ' üÖ¥' : ''}</div>
                                    <div class="track-artist">from ${track.album?.name || 'Unknown Album'}</div>
                                </div>
                                <div class="track-actions">
                                    <button class="btn btn-primary btn-sm" onclick="playFromArtistTracks(${i})">‚ñ∂Ô∏è Play</button>
                                    <button class="btn btn-secondary btn-sm" onclick="addToQueueFromArtistTracks(${i}, false)" style="min-width: 60px;">Queue</button>
                                    <button class="btn btn-warning btn-sm" onclick="addToQueueFromArtistTracks(${i}, true)" style="min-width: 80px;">Play Next</button>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div></div>';
                }
                
                // Albums Section
                if (albumsData.items && albumsData.items.length > 0) {
                    html += `
                        <div style="background:#1e2a45;padding:1.5rem;border-radius:20px;box-shadow:0 4px 20px rgba(0,0,0,0.2);">
                            <h3 style="font-size:1.1rem;font-weight:600;margin-bottom:1rem;">üíø Albums & Singles</h3>
                            <div style="max-height:400px;overflow-y:auto;">
                    `;
                    
                    albumsData.items.forEach((album, i) => {
                        const artwork = album.images?.[0]?.url || '';
                        const albumType = album.album_type === 'single' ? 'Single' : 'Album';
                        html += `
                            <div class="track-item" onclick="showSpotifyAlbumApp('${album.id}', '${album.name.replace(/'/g, "&#39;")}')" style="cursor: pointer;">
                                ${artwork ? `<img src="${artwork}" class="track-artwork">` : '<div class="track-artwork" style="background:#333;display:flex;align-items:center;justify-content:center;">üíø</div>'}
                                <div class="track-info">
                                    <div class="track-name">${album.name}</div>
                                    <div class="track-artist">${albumType} ‚Ä¢ ${album.release_date?.split('-')[0] || 'Unknown Year'} ‚Ä¢ ${album.total_tracks} tracks</div>
                                </div>
                                <div class="track-actions">
                                    <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); playSpotifyAlbum('${album.id}')" ${!spotifyIsPremium || !spotifyPlayerReady ? 'disabled' : ''}>‚ñ∂Ô∏è Play</button>
                                    <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); addAlbumToQueue('${album.id}', false)" style="min-width: 60px;">Queue</button>
                                    <button class="btn btn-warning btn-sm" onclick="event.stopPropagation(); addAlbumToQueue('${album.id}', true)" style="min-width: 80px;">Play Next</button>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div></div>';
                }
                
                if (!html) {
                    html = '<p style="text-align:center;padding:2rem;opacity:0.7;">No tracks or albums found for this artist.</p>';
                }
                
                contentDiv.innerHTML = html;
            } catch (error) {
                console.error('Error loading artist content:', error);
                const contentDiv = document.getElementById('spotify-app-artist-content');
                if (contentDiv) {
                    contentDiv.innerHTML = '<p style="color:#ff6b6b;">‚ùå Failed to load artist content. Please try again.</p>';
                }
                showError('Failed to load artist: ' + error.message);
            }
        }

        // Artist-specific queue functions
        function playFromArtistTracks(trackIndex) {
            if (!window.currentArtistTracks || !window.currentArtistTracks[trackIndex]) {
                showError('Track not found in artist tracks');
                return;
            }
            
            const tracks = window.currentArtistTracks;
            createCustomQueue(tracks, `artist-${window.currentArtistId}`, trackIndex, false);
            playFromCustomQueue(trackIndex);
        }

        function playArtistTracksShuffled() {
            if (!window.currentArtistTracks || window.currentArtistTracks.length === 0) {
                showError('No tracks found for artist');
                return;
            }
            
            const tracks = window.currentArtistTracks;
            // Start with a random track instead of always the first one
            const randomStartIndex = Math.floor(Math.random() * tracks.length);
            createCustomQueue(tracks, `artist-${window.currentArtistId}`, randomStartIndex, true);
            playFromCustomQueue(0); // Play the first track in the shuffled queue
        }

        function addToQueueFromArtistTracks(trackIndex, playNext = false) {
            if (!window.currentArtistTracks || !window.currentArtistTracks[trackIndex]) {
                showError('Track not found in artist tracks');
                return;
            }
            
            const track = window.currentArtistTracks[trackIndex];
            addToCustomQueue(track, playNext);
        }

        // Handle Enter key press in search input
        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchSpotifyApp();
            }
        }

        // Format large numbers with commas
        function formatNumber(num) {
            if (!num) return '0';
            return num.toLocaleString();
        }

        // Show specific search tab
        function showSearchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.search-tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.searchTab === tabName) {
                    btn.classList.add('active');
                }
            });

            // Update tab content
            document.querySelectorAll('.search-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            const targetTab = document.getElementById(`search-tab-${tabName}`);
            if (targetTab) {
                targetTab.style.display = 'block';
    }
}
        async function spotifyPlay() {
    if (spotifyIsPremium && spotifyPlayerReady) {
        spotifyPlayer.resume();
    } else {
        showError('Premium account required for playback controls');
    }
}
        async function spotifyPause() {
    if (spotifyIsPremium && spotifyPlayerReady) {
        spotifyPlayer.pause();
    } else {
        showError('Premium account required for playback controls');
    }
}
        async function spotifyNext() {
    // Check if custom queue is enabled first
    if (customSpotifyNext()) {
        return; // Custom queue handled the next track
    }
    
    // Fall back to Spotify's native next track
    if (spotifyIsPremium && spotifyPlayerReady) {
        spotifyPlayer.nextTrack();
    } else {
        showError('Premium account required for playback controls');
    }
}
        async function spotifyPrev() {
    // Check if custom queue is enabled first
    if (customSpotifyPrev()) {
        return; // Custom queue handled the previous track
    }
    
    // Fall back to Spotify's native previous track
    if (spotifyIsPremium && spotifyPlayerReady) {
        spotifyPlayer.previousTrack();
    } else {
        showError('Premium account required for playback controls');
    }
}
        function updateSpotifyPlayerBar() {
    if (!spotifyCurrentTrack) return;
    const albumart = document.getElementById('spotify-player-albumart');
    const trackinfo = document.getElementById('spotify-player-trackinfo');
    const artistinfo = document.getElementById('spotify-player-artistinfo');
    if (spotifyCurrentTrack.album && spotifyCurrentTrack.album.images && spotifyCurrentTrack.album.images.length > 0) {
        albumart.src = spotifyCurrentTrack.album.images[0].url;
        albumart.style.display = 'block';
    } else {
        albumart.style.display = 'none';
    }
    trackinfo.textContent = spotifyCurrentTrack.name;
    artistinfo.textContent = spotifyCurrentTrack.artists.map(a=>a.name).join(', ');
    
    // Update total time when track changes
    const totalTimeEl = document.getElementById('spotify-total-time');
    if (totalTimeEl && spotifyCurrentTrack.duration_ms) {
        totalTimeEl.textContent = formatTime(spotifyCurrentTrack.duration_ms);
    }
}
        function showError(message) {
            // ... (copy the full function from 1.html)
        }
        function showSuccess(message) {
            // ... (copy the full function from 1.html)
        }
        function showInfo(message) {
            // ... (copy the full function from 1.html)
        }
        // --- Ensure these are at the very end of the <script> ---
        document.addEventListener('DOMContentLoaded', () => {
            setupSpotifyLoginButton();
            setupSpotifyOpenMusicButton();
            setupProgressBar(); // Initialize progress bar
            updateSpotifyButtons();

            // Set up event listeners for all Spotify buttons
            setTimeout(() => {
                setupSpotifyLoginButton();
                setupSpotifyOpenMusicButton();
                setupProgressBar(); // Initialize again after delay
                updateSpotifyButtonsOnAllScreens();
            }, 500);

            // Attach event listeners for game selection buttons
            const moleBtn = document.getElementById('play-mole-btn');
            const nbaBtn = document.getElementById('play-nba-btn');
            const rapperBtn = document.getElementById('play-rapper-btn');
            console.log('Game buttons found:', { moleBtn: !!moleBtn, nbaBtn: !!nbaBtn, rapperBtn: !!rapperBtn });
            if (moleBtn) moleBtn.onclick = () => selectGame('mole');
            if (nbaBtn) nbaBtn.onclick = () => selectGame('nba');
            if (rapperBtn) rapperBtn.onclick = () => selectGame('rapper');
        });

        document.getElementById('spotify-play-btn-app').addEventListener('click', spotifyPlay);
        document.getElementById('spotify-pause-btn-app').addEventListener('click', spotifyPause);
        document.getElementById('spotify-next-btn-app').addEventListener('click', spotifyNext);
        document.getElementById('spotify-prev-btn-app').addEventListener('click', spotifyPrev);

        // Add missing searchSpotifyApp function
        function searchSpotifyApp() {
            console.log('üîç searchSpotifyApp called');
            const q = document.getElementById('spotify-app-search-input').value.trim();
            console.log('üîç Search query:', q);
            
            if (!q) {
                showError('Please enter a search term');
                return;
            }
            const resultsDiv = document.getElementById('spotify-app-search-results');
            resultsDiv.innerHTML = '<div style="text-align:center;padding:2rem;"><span class="loading-spinner"></span> Searching...</div>';
            
            const searchUrl = `https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=track,artist,album&limit=20`;
            console.log('üîç Search URL:', searchUrl);
            
            fetch(searchUrl, {
                headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`Spotify API error: ${res.status}`);
                }
                return res.json();
            })
            .then(data => {
                console.log('üîç Search results:', data);
                console.log('üîç Tracks found:', data.tracks?.items?.length);
                console.log('üîç Artists found:', data.artists?.items?.length);
                console.log('üîç Albums found:', data.albums?.items?.length);
                
                // Hide old results and show tabbed interface
                resultsDiv.innerHTML = '';
                const tabsContainer = document.getElementById('spotify-search-tabs');
                if (tabsContainer) {
                    tabsContainer.style.display = 'block';
                }
                
                // Populate Tracks tab
                let tracksHtml = '';
                if (data.tracks && data.tracks.items.length > 0) {
                    data.tracks.items.forEach(t => {
                        const explicitIcon = t.explicit ? ' üÖ¥' : '';
                        tracksHtml += `<div class="track-item">
                            <img src="${t.album.images[0]?.url || ''}" class="track-artwork">
                            <div class="track-info">
                                <div class="track-name">${t.name}${explicitIcon}</div>
                                <div class="track-artist">${t.artists.map(a=>a.name).join(', ')}</div>
                            </div>
                            <div class="track-actions">
                                <button class="btn btn-primary" onclick="playSpotifyTrackId('${t.id}')">‚ñ∂Ô∏è Play</button>
                                <button class="btn btn-secondary" onclick="addSearchTrackToQueue('${t.id}', false)" style="min-width: 60px;">Queue</button>
                                <button class="btn btn-warning" onclick="addSearchTrackToQueue('${t.id}', true)" style="min-width: 80px;">Play Next</button>
                            </div>
                        </div>`;
                    });
                } else {
                    tracksHtml = '<p style="text-align:center;padding:2rem;opacity:0.7;">No tracks found.</p>';
                }
                document.getElementById('search-tab-tracks').innerHTML = tracksHtml;
                
                // Populate Albums tab
                let albumsHtml = '';
                if (data.albums && data.albums.items.length > 0) {
                    data.albums.items.forEach(al => {
                        const explicitIcon = al.explicit ? ' üÖ¥' : '';
                        albumsHtml += `<div class="track-item" onclick="showSpotifyAlbumApp('${al.id}', '${al.name.replace(/'/g, "&#39;")}')" style="cursor: pointer;">
                            <img src="${al.images && al.images.length > 0 ? al.images[0].url : ''}" class="track-artwork">
                            <div class="track-info">
                                <div class="track-name">${al.name}${explicitIcon}</div>
                                <div class="track-artist">${al.artists.map(a=>a.name).join(', ')}</div>
                            </div>
                            <div class="track-actions">
                                <button class="btn btn-info" onclick="event.stopPropagation(); showSpotifyAlbumApp('${al.id}', '${al.name.replace(/'/g, "&#39;")}')">View Album</button>
                            </div>
                        </div>`;
                    });
                } else {
                    albumsHtml = '<p style="text-align:center;padding:2rem;opacity:0.7;">No albums found.</p>';
                }
                document.getElementById('search-tab-albums').innerHTML = albumsHtml;
                
                // Populate Artists tab
                let artistsHtml = '';
                if (data.artists && data.artists.items.length > 0) {
                    data.artists.items.forEach(a => {
                        artistsHtml += `<div class="track-item" onclick="showSpotifyArtistApp('${a.id}', '${a.name.replace(/'/g, "&#39;")}')" style="cursor: pointer;">
                            <img src="${a.images && a.images.length > 0 ? a.images[0].url : ''}" class="track-artwork">
                            <div class="track-info">
                                <div class="track-name">${a.name}</div>
                                <div class="track-artist">${formatNumber(a.followers?.total || 0)} followers</div>
                            </div>
                            <div class="track-actions">
                                <button class="btn btn-info" onclick="event.stopPropagation(); showSpotifyArtistApp('${a.id}', '${a.name.replace(/'/g, "&#39;")}')">View Artist</button>
                            </div>
                        </div>`;
                    });
                } else {
                    artistsHtml = '<p style="text-align:center;padding:2rem;opacity:0.7;">No artists found.</p>';
                }
                document.getElementById('search-tab-artists').innerHTML = artistsHtml;
                
                // Show the tracks tab by default
                showSearchTab('tracks');
            })
            .catch(error => {
                console.error('üîç Spotify search error:', error);
                console.error('üîç Error details:', error.message);
                resultsDiv.innerHTML = '<p style="text-align:center;padding:2rem;color:#ff6b6b;">‚ùå Search failed. Please try again.</p>';
                showError('Failed to search Spotify: ' + error.message);
            });
        }
        
        // Progress bar functionality
        let isUserSeeking = false;
        let spotifyProgressInterval;
        let hasAutoAdvanced = false; // Track if we've already auto-advanced for current track
        
        function setupProgressBar() {
            const progressBar = document.getElementById('spotify-progress-bar');
            if (!progressBar) return;
            
            progressBar.addEventListener('mousedown', () => {
                isUserSeeking = true;
            });
            
            progressBar.addEventListener('mouseup', () => {
                if (isUserSeeking && spotifyAccessToken && spotifyDeviceId) {
                    const position = (progressBar.value / 100) * spotifyCurrentTrack?.duration_ms;
                    if (position && position > 0) {
                        fetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${Math.floor(position)}&device_id=${spotifyDeviceId}`, {
                            method: 'PUT',
                            headers: {
                                'Authorization': 'Bearer ' + spotifyAccessToken
                            }
                        }).catch(error => console.error('Seek error:', error));
                    }
                }
                isUserSeeking = false;
            });
            
            progressBar.addEventListener('input', () => {
                if (isUserSeeking && spotifyCurrentTrack?.duration_ms) {
                    const currentPos = (progressBar.value / 100) * spotifyCurrentTrack.duration_ms;
                    document.getElementById('spotify-current-time').textContent = formatTime(currentPos);
                }
            });
        }
        
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updateProgressBar() {
            if (isUserSeeking) return;
            
            const progressBar = document.getElementById('spotify-progress-bar');
            const currentTimeEl = document.getElementById('spotify-current-time');
            const totalTimeEl = document.getElementById('spotify-total-time');
            
            if (!progressBar || !spotifyCurrentTrack) return;
            
            if (spotifyPlayer) {
                spotifyPlayer.getCurrentState().then(state => {
                    if (state && state.track_window.current_track) {
                        const position = state.position;
                        const duration = state.track_window.current_track.duration_ms;
                        
                        if (duration > 0) {
                            const progress = (position / duration) * 100;
                            progressBar.value = progress;
                            
                            if (currentTimeEl) currentTimeEl.textContent = formatTime(position);
                            if (totalTimeEl) totalTimeEl.textContent = formatTime(duration);
                            
                            // Auto-advance to next track when current track is nearly finished
                            // Check if we're within 2 seconds of the end and haven't already auto-advanced
                            const timeRemaining = duration - position;
                            if (timeRemaining <= 2000 && !hasAutoAdvanced && spotifyQueueEnabled) {
                                hasAutoAdvanced = true;
                                console.log('Track ending detected, auto-advancing to next track...');
                                
                                // Small delay to ensure the track has actually ended
                                setTimeout(() => {
                                    if (customSpotifyNext()) {
                                        console.log('Auto-advanced to next track in custom queue');
                                    } else {
                                        console.log('End of custom queue reached');
                                    }
                                }, 1500);
                            }
                        }
                    }
                });
            }
        }
        
        function startProgressTracking() {
            if (spotifyProgressInterval) clearInterval(spotifyProgressInterval);
            spotifyProgressInterval = setInterval(updateProgressBar, 1000);
        }
        
        function stopProgressTracking() {
            if (spotifyProgressInterval) {
                clearInterval(spotifyProgressInterval);
                spotifyProgressInterval = null;
            }
        }
        
        // Enhanced API request function with retry logic
        async function makeSpotifyRequest(endpoint, params = {}, method = 'GET', retryCount = 0) {
            if (!spotifyAccessToken) {
                return { error: 'Not authenticated' };
            }

            try {
                const url = new URL(`https://api.spotify.com/v1/${endpoint}`);
                if (method === 'GET' && Object.keys(params).length > 0) {
                    Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));
                }

                const config = {
                    method: method,
                    headers: {
                        'Authorization': `Bearer ${spotifyAccessToken}`,
                        'Content-Type': 'application/json'
                    }
                };

                const response = await fetch(url, config);
                
                if (!response.ok) {
                    if (response.status === 401) {
                        console.log('üîÑ Token expired');
                        return { error: 'Token expired' };
                    }
                    
                    // Handle 403 Forbidden (insufficient permissions)
                    if (response.status === 403) {
                        console.log(`‚ö†Ô∏è Insufficient permissions for ${endpoint}`);
                        return { error: 'Request failed: 403', items: [], tracks: [], playlists: { items: [] }, albums: { items: [] } };
                    }
                    
                    // Handle 404 Not Found (endpoint may not be available)
                    if (response.status === 404) {
                        console.log(`‚ùå Endpoint not found: ${endpoint}`);
                        return { error: 'Request failed: 404', items: [], tracks: [], playlists: { items: [] }, albums: { items: [] } };
                    }
                    
                    // Handle rate limiting with exponential backoff
                    if (response.status === 429 && retryCount < 3) {
                        const delay = Math.pow(2, retryCount) * 1000;
                        console.log(`‚è≥ Rate limited, retrying in ${delay}ms (attempt ${retryCount + 1}/3)`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return makeSpotifyRequest(endpoint, params, method, retryCount + 1);
                    }
                    
                    return { error: `Request failed: ${response.status}`, items: [], tracks: [], playlists: { items: [] }, albums: { items: [] } };
                }
                
                // Safe JSON parsing
                const text = await response.text();
                if (!text) {
                    return { error: 'Empty response', items: [], tracks: [], playlists: { items: [] }, albums: { items: [] } };
                }
                
                try {
                    return JSON.parse(text);
                } catch (parseError) {
                    console.error('JSON parse error:', parseError);
                    return { error: 'Invalid JSON response', items: [], tracks: [], playlists: { items: [] }, albums: { items: [] } };
                }
            } catch (error) {
                console.error('API request error:', error);
                return { error: `Network error: ${error.message}`, items: [], tracks: [], playlists: { items: [] }, albums: { items: [] } };
            }
        }
        
        // Cache for listening stats to avoid recalculating
        let cachedListeningStats = null;
        let cacheTimestamp = 0;
        const CACHE_DURATION = 15 * 60 * 1000; // 15 minutes (increased for faster loading)
        
        // Artist data cache to avoid repeated API calls
        let artistCache = new Map();
        const ARTIST_CACHE_DURATION = 30 * 60 * 1000; // 30 minutes
        
        // Cached artist fetching function
        async function getCachedArtistData(artistId) {
            const now = Date.now();
            const cached = artistCache.get(artistId);
            
            if (cached && (now - cached.timestamp) < ARTIST_CACHE_DURATION) {
                return cached.data;
            }
            
            try {
                // Add delay to prevent rate limiting
                await new Promise(resolve => setTimeout(resolve, 300));
                const response = await fetch(`https://api.spotify.com/v1/artists/${artistId}`, {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                
                if (response.ok) {
                    const artistData = await response.json();
                    artistCache.set(artistId, { data: artistData, timestamp: now });
                    return artistData;
                }
            } catch (error) {
                console.error('Artist fetch error:', error);
            }
            
            return null;
        }

        // Get or calculate listening stats with caching
        async function getCachedListeningStats(quickMode = false) {
            const now = Date.now();
            
            // Try to load from localStorage first
            if (!cachedListeningStats) {
                try {
                    const stored = localStorage.getItem('spotifyListeningStatsCache');
                    if (stored) {
                        const { data, timestamp } = JSON.parse(stored);
                        if ((now - timestamp) < CACHE_DURATION) {
                            console.log('üìä Using localStorage cached listening stats');
                            cachedListeningStats = data;
                            cacheTimestamp = timestamp;
                            return cachedListeningStats;
                        }
                    }
                } catch (error) {
                    console.log('Error loading cached stats from localStorage:', error);
                }
            }
            
            if (cachedListeningStats && (now - cacheTimestamp) < CACHE_DURATION) {
                console.log('üìä Using memory cached listening stats');
                return cachedListeningStats;
            }
            
            if (quickMode) {
                console.log('üìä Using quick mode - minimal API calls');
                // Just get basic data without heavy calculations
                const [recentTracks, topTracks, playlists] = await Promise.all([
                    makeSpotifyRequest('me/player/recently-played', { limit: 10 }).catch(() => ({ items: [] })),
                    makeSpotifyRequest('me/top/tracks', { limit: 10 }).catch(() => ({ items: [] })),
                    makeSpotifyRequest('me/playlists', { limit: 10 }).catch(() => ({ items: [] }))
                ]);
                
                // Return basic stats without genre analysis
                return {
                    recentTracks: recentTracks.items || [],
                    topTracks: topTracks.items || [],
                    playlists: playlists.items || [],
                    generalGenreStats: {},
                    topGenres: [],
                    studySongs: [],
                    listeningPatterns: { morning: 0, daytime: 0, evening: 0, night: 0 }
                };
            }
            
            console.log('üìä Calculating fresh listening stats...');
            const [recentTracks, topTracks, playlists] = await Promise.all([
                makeSpotifyRequest('me/player/recently-played', { limit: 50 }).catch(() => ({ items: [] })),
                makeSpotifyRequest('me/top/tracks', { limit: 20 }).catch(() => ({ items: [] })),
                makeSpotifyRequest('me/playlists', { limit: 50 }).catch(() => ({ items: [] }))
            ]);
            
            cachedListeningStats = await calculateListeningStats(
                recentTracks.items || [], 
                topTracks.items || [], 
                playlists.items || []
            );
            cacheTimestamp = now;
            
            // Save to localStorage for persistence
            try {
                localStorage.setItem('spotifyListeningStatsCache', JSON.stringify({
                    data: cachedListeningStats,
                    timestamp: cacheTimestamp
                }));
                console.log('üíæ Saved listening stats to localStorage cache');
            } catch (error) {
                console.log('Error saving stats to localStorage:', error);
            }
            
            return cachedListeningStats;
        }

        // Stats & Analytics Functions
        async function showSpotifyStats() {
            const main = document.getElementById('spotify-main');
            if (!spotifyAccessToken) {
                main.innerHTML = '<p style="color:#ff6b6b;text-align:center;">Please log in to Spotify to use this feature.</p>';
                return;
            }
            main.innerHTML = '<div style="text-align:center;padding:2rem;"><span class="loading-spinner"></span> Loading Stats...</div>';
            try {
                console.log('Loading stats with enhanced API...');
                const [topTracks, topArtists, recentlyPlayed, audioFeatures] = await Promise.all([
                    makeSpotifyRequest('me/top/tracks', { limit: 10, time_range: 'medium_term' }),
                    makeSpotifyRequest('me/top/artists', { limit: 10, time_range: 'medium_term' }),
                    makeSpotifyRequest('me/player/recently-played', { limit: 20 }).then(result => {
                        if (result.error && result.error.includes('403')) {
                            console.log('üîÑ Recently-played failed, using top tracks as fallback');
                            return makeSpotifyRequest('me/top/tracks', { limit: 20, time_range: 'short_term' });
                        }
                        return result;
                    }),
                    spotifyCurrentTrack ? makeSpotifyRequest(`audio-features/${spotifyCurrentTrack.id}`) : Promise.resolve(null)
                ]);
                
                console.log('API responses received:', { 
                    topTracks: topTracks.items?.length || (topTracks.error ? `Error: ${topTracks.error}` : 0),
                    topArtists: topArtists.items?.length || (topArtists.error ? `Error: ${topArtists.error}` : 0),
                    recentlyPlayed: recentlyPlayed.items?.length || (recentlyPlayed.error ? `Error: ${recentlyPlayed.error}` : 0)
                });
                
                let html = `<h2>üìà Your Music Stats & Analytics</h2>`;
                
                // Listening Analytics
                html += `<div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-bottom:2rem;">`;
                
                // Top Tracks
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;">
                    <h3>üéµ Top Tracks (Last 6 Months)</h3>`;
                if (topTracks.items) {
                    topTracks.items.slice(0, 5).forEach((track, i) => {
                        html += `<div class="track-item" style="margin:0.5rem 0;">
                            <img src="${track.album.images[0]?.url || ''}" class="track-artwork" style="width:30px;height:30px;">
                            <div class="track-info">
                                <div class="track-name" style="font-size:0.9rem;">${i+1}. ${track.name}</div>
                                <div class="track-artist" style="font-size:0.8rem;">${track.artists.map(a=>a.name).join(', ')}</div>
                            </div>
                            <button class="btn btn-sm btn-primary" onclick="playSpotifyTrackId('${track.id}')">‚ñ∂Ô∏è</button>
                        </div>`;
                    });
                }
                html += `</div>`;
                
                // Top Artists
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;">
                    <h3>üé§ Top Artists (Last 6 Months)</h3>`;
                if (topArtists.items) {
                    topArtists.items.slice(0, 5).forEach((artist, i) => {
                        html += `<div class="track-item" style="margin:0.5rem 0;">
                            <img src="${artist.images[0]?.url || ''}" class="track-artwork" style="width:30px;height:30px;">
                            <div class="track-info">
                                <div class="track-name" style="font-size:0.9rem;">${i+1}. ${artist.name}</div>
                                <div class="track-artist" style="font-size:0.8rem;">${artist.followers?.total?.toLocaleString() || 0} followers</div>
                            </div>
                        </div>`;
                    });
                }
                html += `</div></div>`;
                
                // Audio Features (if playing)
                if (audioFeatures && !audioFeatures.error) {
                    html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;margin-bottom:1.5rem;">
                        <h3>üéº Current Track Analysis</h3>
                        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;margin-top:1rem;">
                            <div style="text-align:center;">
                                <div style="font-size:2rem;color:#1db954;">${Math.round(audioFeatures.energy * 100)}%</div>
                                <div style="font-size:0.8rem;opacity:0.7;">Energy</div>
                            </div>
                            <div style="text-align:center;">
                                <div style="font-size:2rem;color:#1db954;">${Math.round(audioFeatures.danceability * 100)}%</div>
                                <div style="font-size:0.8rem;opacity:0.7;">Danceability</div>
                            </div>
                            <div style="text-align:center;">
                                <div style="font-size:2rem;color:#1db954;">${Math.round(audioFeatures.valence * 100)}%</div>
                                <div style="font-size:0.8rem;opacity:0.7;">Positivity</div>
                            </div>
                            <div style="text-align:center;">
                                <div style="font-size:2rem;color:#1db954;">${Math.round(audioFeatures.tempo)}</div>
                                <div style="font-size:0.8rem;opacity:0.7;">BPM</div>
                            </div>
                        </div>
                    </div>`;
                }
                
                // Recent Listening Activity
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;">
                    <h3>üïì Recent Listening Activity</h3>`;
                if (recentlyPlayed.items && recentlyPlayed.items.length > 0) {
                    recentlyPlayed.items.slice(0, 10).forEach(item => {
                        const track = item.track || item; // Handle both formats
                        const playedAt = item.played_at ? new Date(item.played_at).toLocaleString() : 'Recently played';
                        if (track && track.name) {
                            html += `<div class="track-item" style="margin:0.5rem 0;">
                                <img src="${track.album?.images?.[0]?.url || ''}" class="track-artwork" style="width:30px;height:30px;">
                                <div class="track-info">
                                    <div class="track-name" style="font-size:0.9rem;">${track.name}</div>
                                    <div class="track-artist" style="font-size:0.8rem;">${track.artists?.map(a=>a.name).join(', ') || 'Unknown Artist'} ‚Ä¢ ${playedAt}</div>
                                </div>
                                <button class="btn btn-sm btn-primary" onclick="playSpotifyTrackId('${track.id}')">‚ñ∂Ô∏è</button>
                            </div>`;
                        }
                    });
                }
                html += `</div>`;
                
                main.innerHTML = html;
            } catch (error) {
                console.error('Stats error:', error);
                main.innerHTML = '<p style="text-align:center;padding:2rem;color:#ff6b6b;">Failed to load stats. Please try again.</p>';
            }
        }
        
        // Study Mode Functions
        async function showSpotifyStudyMode() {
            const main = document.getElementById('spotify-main');
            if (!spotifyAccessToken) {
                main.innerHTML = '<p style="color:#ff6b6b;text-align:center;">Please log in to Spotify to use this feature.</p>';
                return;
            }
            main.innerHTML = '<div style="text-align:center;padding:2rem;"><span class="loading-spinner"></span> Loading Study Mode...</div>';
            try {
                // Get user data and study-focused playlists
                const [publicStudyPlaylists, userPlaylists, recentTracks] = await Promise.all([
                    fetch('https://api.spotify.com/v1/search?q=study%20focus%20lofi%20instrumental&type=playlist&limit=20', {
                        headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                    }).then(r => r.json()),
                    makeSpotifyRequest('me/playlists', { limit: 50 }),
                    makeSpotifyRequest('me/player/recently-played', { limit: 50 })
                ]);
                
                let html = `<h2>üìñ Study Mode - Focus & Productivity</h2>`;
                
                // Study Timer
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;margin-bottom:1.5rem;">
                    <h3>‚è±Ô∏è Pomodoro Timer</h3>
                    <div style="display:flex;align-items:center;justify-content:center;gap:1rem;margin:1rem 0;">
                        <div id="study-timer" style="font-size:3rem;font-weight:bold;color:#1db954;">25:00</div>
                    </div>
                    <div style="text-align:center;gap:0.5rem;display:flex;justify-content:center;">
                        <button class="btn btn-primary" onclick="startStudyTimer(25)">üçÖ Focus (25min)</button>
                        <button class="btn btn-secondary" onclick="startStudyTimer(5)">‚òï Break (5min)</button>
                        <button class="btn btn-danger" onclick="stopStudyTimer()">‚èπÔ∏è Stop</button>
                    </div>
                    <div style="margin-top:1rem;text-align:center;">
                        <label><input type="checkbox" id="auto-play-study" checked> Auto-play study music during timer</label>
                    </div>
                </div>`;
                
                // Study Playlists
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;margin-bottom:1.5rem;">
                    <h3>üéµ Study Playlists</h3>
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:1rem;margin-top:1rem;">`;
                
                if (publicStudyPlaylists.playlists?.items) {
                    publicStudyPlaylists.playlists.items.slice(0, 8).forEach(playlist => {
                        if (playlist && playlist.name) {
                            html += `<div style="background:#232b3e;padding:1rem;border-radius:10px;">
                                <img src="${playlist.images?.[0]?.url || ''}" style="width:100%;height:150px;object-fit:cover;border-radius:8px;margin-bottom:0.5rem;">
                                <div style="font-weight:bold;margin-bottom:0.25rem;">${playlist.name}</div>
                                <div style="font-size:0.8rem;opacity:0.7;margin-bottom:0.5rem;">${playlist.tracks?.total || 0} tracks</div>
                                <button class="btn btn-primary btn-sm" onclick="playSpotifyPlaylistId('${playlist.id}')">‚ñ∂Ô∏è Play</button>
                            </div>`;
                        }
                    });
                }
                
                html += `</div></div>`;
                
                // Study Stats
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;">
                    <h3>üìà Study Session Stats</h3>
                    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin-top:1rem;">
                        <div style="text-align:center;">
                            <div style="font-size:2rem;color:#1db954;" id="total-study-time">0h 0m</div>
                            <div style="font-size:0.8rem;opacity:0.7;">Total Today</div>
                        </div>
                        <div style="text-align:center;">
                            <div style="font-size:2rem;color:#1db954;" id="study-sessions">0</div>
                            <div style="font-size:0.8rem;opacity:0.7;">Sessions</div>
                        </div>
                        <div style="text-align:center;">
                            <div style="font-size:2rem;color:#1db954;" id="current-streak">0</div>
                            <div style="font-size:0.8rem;opacity:0.7;">Day Streak</div>
                        </div>
                    </div>
                    
                    <!-- Weekly Stats -->
                    <div style="margin-top:2rem;">
                        <h4>üìÖ Weekly Study Time</h4>
                        <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:1rem;margin-top:1rem;">
                            <div style="text-align:center;">
                                <div style="font-size:1.5rem;color:#1db954;" id="weekly-total">0h 0m</div>
                                <div style="font-size:0.8rem;opacity:0.7;">This Week</div>
                            </div>
                            <div style="text-align:center;">
                                <div style="font-size:1.5rem;color:#1db954;" id="weekly-average">0h 0m</div>
                                <div style="font-size:0.8rem;opacity:0.7;">Daily Average</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Daily Breakdown -->
                    <div style="margin-top:2rem;">
                        <h4>üìä Daily Breakdown (Past 7 Days)</h4>
                        <div style="display:grid;grid-template-columns:repeat(7,1fr);gap:0.5rem;margin-top:1rem;" id="daily-breakdown">
                            <!-- Days will be populated by JavaScript -->
                        </div>
                    </div>
                </div>`;
                
                main.innerHTML = html;
                loadStudyStats();
            } catch (error) {
                console.error('Study mode error:', error);
                main.innerHTML = '<p style="text-align:center;padding:2rem;color:#ff6b6b;">Failed to load study mode. Please try again.</p>';
            }
        }

        // Make Spotify functions globally accessible
        window.showSpotifyPlaylistApp = showSpotifyPlaylistApp;
        window.playSpotifyPlaylistId = playSpotifyPlaylistId;
        window.shuffleSpotifyPlaylist = shuffleSpotifyPlaylist;
        window.queueSpotifyTrack = queueSpotifyTrack;
        window.playSpotifyTrackId = playSpotifyTrackId;
        window.searchSpotifyApp = searchSpotifyApp;
        window.searchSpotifyGenre = searchSpotifyGenre;
        window.setupProgressBar = setupProgressBar;
        window.startProgressTracking = startProgressTracking;
        window.stopProgressTracking = stopProgressTracking;
        window.showSpotifyStats = showSpotifyStats;
        window.showSpotifyStudyMode = showSpotifyStudyMode;
        
        // Recommendations & Discovery Functions
        async function showSpotifyRecommendations() {
            const main = document.getElementById('spotify-main');
            if (!spotifyAccessToken) {
                main.innerHTML = '<p style="color:#ff6b6b;text-align:center;">Please log in to Spotify to use this feature.</p>';
                return;
            }
            main.innerHTML = '<div style="text-align:center;padding:2rem;"><span class="loading-spinner"></span> Loading Study Recommendations...</div>';
            try {
                // Get user's recent tracks and playlists to find study-related content
                const [recentTracks, userPlaylists] = await Promise.all([
                    makeSpotifyRequest('me/player/recently-played', { limit: 50 }).catch(() => ({ items: [] })),
                    makeSpotifyRequest('me/playlists', { limit: 50 }).catch(() => ({ items: [] }))
                ]);
                
                let html = `<h2>üìñ Study Music Recommendations</h2>`;
                
                // Study keywords to identify study-related content
                const studyKeywords = ['study', 'focus', 'concentration', 'lofi', 'lo-fi', 'ambient', 'chill', 'school', 'reading', 'work', 'meditation', 'instrumental', 'piano', 'classical'];
                
                // Find study tracks from recent listening
                let studyTracks = [];
                if (recentTracks.items) {
                    studyTracks = recentTracks.items.filter(item => {
                        const track = item.track || item;
                        if (!track) return false;
                        const searchText = `${track.name} ${track.artists?.map(a => a.name).join(' ') || ''} ${track.album?.name || ''}`.toLowerCase();
                        return studyKeywords.some(keyword => searchText.includes(keyword));
                    }).slice(0, 10);
                }
                
                // Find user's study playlists
                let userStudyPlaylists = [];
                if (userPlaylists.items) {
                    userStudyPlaylists = userPlaylists.items.filter(playlist => {
                        if (!playlist || !playlist.name) return false;
                        const searchText = `${playlist.name} ${playlist.description || ''}`.toLowerCase();
                        return studyKeywords.some(keyword => searchText.includes(keyword));
                    }).slice(0, 8);
                }
                
                // Recommended Study Tracks
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;margin-bottom:1.5rem;">
                    <h3>üéµ Recommended Study Tracks</h3>
                    <p style="margin-bottom:1rem;color:#b3b3b3;font-size:0.9rem;">Based on your recent listening history</p>`;
                
                if (studyTracks.length > 0) {
                    studyTracks.forEach(item => {
                        const track = item.track || item;
                        if (track && track.name) {
                            html += `<div class="track-item" style="margin:0.5rem 0;">
                                <img src="${track.album?.images?.[0]?.url || ''}" class="track-artwork" style="width:40px;height:40px;">
                                <div class="track-info">
                                    <div class="track-name" style="font-size:0.9rem;">${track.name}</div>
                                    <div class="track-artist" style="font-size:0.8rem;">${track.artists?.map(a=>a.name).join(', ') || 'Unknown Artist'}</div>
                                </div>
                                <div class="track-actions">
                                    <button class="btn btn-primary btn-sm" onclick="playSpotifyTrackId('${track.id}')">‚ñ∂Ô∏è Play</button>
                                    <button class="btn btn-secondary btn-sm" onclick="queueSpotifyTrack('${track.id}')">‚ûï Queue</button>
                                </div>
                            </div>`;
                        }
                    });
                } else {
                    html += `<p style="color:#999;text-align:center;">No study tracks found in recent history</p>`;
                }
                html += `</div>`;
                
                // Featured Playlists
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;margin-bottom:1.5rem;">
                    <h3>üìö Your Study Playlists</h3>
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-top:1rem;">`;
                
                if (userStudyPlaylists.length > 0) {
                    userStudyPlaylists.forEach(playlist => {
                        html += `<div style="background:#232b3e;padding:1rem;border-radius:10px;">
                            <img src="${playlist.images?.[0]?.url || ''}" style="width:100%;height:120px;object-fit:cover;border-radius:8px;margin-bottom:0.5rem;">
                            <div style="font-weight:bold;margin-bottom:0.25rem;font-size:0.9rem;">${playlist.name}</div>
                            <div style="font-size:0.8rem;opacity:0.7;margin-bottom:0.5rem;">${playlist.tracks?.total || 0} tracks</div>
                            <button class="btn btn-primary btn-sm" onclick="playSpotifyPlaylistId('${playlist.id}')">‚ñ∂Ô∏è Play</button>
                        </div>`;
                    });
                } else {
                    html += `<p style="color:#999;text-align:center;">No study playlists found</p>`;
                }
                
                html += `</div></div>`;
                
                // Popular Study Genres
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;margin-bottom:1.5rem;">
                    <h3>üéß Popular Study Music</h3>
                    <p style="margin-bottom:1rem;color:#b3b3b3;font-size:0.9rem;">Discover popular study music genres and artists</p>
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:1rem;">`;
                
                const studyGenres = [
                    { name: 'Lo-Fi Hip Hop', search: 'lofi hip hop study', icon: 'üéµ' },
                    { name: 'Ambient Study', search: 'ambient chill study', icon: 'üåä' },
                    { name: 'Classical Piano', search: 'classical piano study', icon: 'üéπ' },
                    { name: 'Nature Sounds', search: 'nature sounds study', icon: 'üåø' },
                    { name: 'Instrumental', search: 'instrumental study music', icon: 'üéº' },
                    { name: 'Meditation', search: 'meditation focus music', icon: 'üßò' }
                ];
                
                studyGenres.forEach(genre => {
                    html += `<div style="background:#232b3e;padding:1rem;border-radius:10px;text-align:center;">
                        <div style="font-size:2rem;margin-bottom:0.5rem;">${genre.icon}</div>
                        <div style="font-weight:bold;margin-bottom:0.5rem;font-size:0.9rem;">${genre.name}</div>
                        <button class="btn btn-primary btn-sm" onclick="searchSpotifyGenre('${genre.search}')">üîç Explore</button>
                    </div>`;
                });
                
                html += `</div></div>`;
                
                // Study Radio Stations
                html += `<div style="background:#1c253b;padding:1.5rem;border-radius:15px;">
                    <h3>üìª Study Radio Stations</h3>
                    <p style="margin-bottom:1rem;color:#b3b3b3;font-size:0.9rem;">Continuous study music streams</p>
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;">`;
                
                const studyRadios = [
                    { name: 'Lo-Fi Study Radio', artist: 'ChilledCow', icon: 'üìª' },
                    { name: 'Focus Flow', artist: 'Study Music', icon: 'üéØ' },
                    { name: 'Deep Focus', artist: 'Spotify', icon: 'üß†' },
                    { name: 'Chill Instrumental', artist: 'Various Artists', icon: 'üéµ' }
                ];
                
                studyRadios.forEach(radio => {
                    html += `<div style="background:#232b3e;padding:1rem;border-radius:10px;">
                        <div style="font-size:2rem;text-align:center;margin-bottom:0.5rem;">${radio.icon}</div>
                        <div style="font-weight:bold;margin-bottom:0.25rem;font-size:0.9rem;">${radio.name}</div>
                        <div style="font-size:0.8rem;opacity:0.7;margin-bottom:0.5rem;">${radio.artist}</div>
                        <button class="btn btn-primary btn-sm" onclick="searchSpotifyGenre('${radio.name}')">üéß Listen</button>
                    </div>`;
                });
                
                html += `</div></div>`;
                
                main.innerHTML = html;
                window.currentRecommendations = studyTracks.map(item => item.track || item);
            } catch (error) {
                console.error('Recommendations error:', error);
                main.innerHTML = '<p style="text-align:center;padding:2rem;color:#ff6b6b;">Failed to load recommendations. Please try again.</p>';
            }
        }
        
        // Search for study genres
        function searchSpotifyGenre(query) {
            const searchInput = document.getElementById('spotify-app-search-input');
            if (searchInput) {
                searchInput.value = query;
                searchSpotifyApp();
            } else {
                // If we're not in the search tab, perform a direct search
                console.log('Searching for:', query);
                // This could be expanded to perform a direct API search
                alert(`Searching for: ${query}`);
            }
        }
        
        // Study Timer Functions
        let studyTimer = null;
        let studyTimeLeft = 0;
        
        function startStudyTimer(minutes) {
            stopStudyTimer();
            studyTimeLeft = minutes * 60;
            updateStudyTimerDisplay();
            
            studyTimer = setInterval(() => {
                studyTimeLeft--;
                updateStudyTimerDisplay();
                
                if (studyTimeLeft <= 0) {
                    stopStudyTimer();
                    showSuccess(`${minutes === 25 ? 'Focus' : 'Break'} session completed!`);
                    updateStudyStats(minutes);
                    
                    // Auto-start break or focus
                    if (minutes === 25) {
                        setTimeout(() => startStudyTimer(5), 2000);
                    }
                }
            }, 1000);
            
            // Auto-play study music if enabled
            if (minutes === 25 && document.getElementById('auto-play-study')?.checked) {
                fetch('https://api.spotify.com/v1/search?q=lofi%20study%20instrumental&type=playlist&limit=1', {
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                }).then(r => r.json()).then(data => {
                    if (data.playlists?.items[0]) {
                        playSpotifyPlaylistId(data.playlists.items[0].id);
                    }
                });
            }
        }
        
        function stopStudyTimer() {
            if (studyTimer) {
                clearInterval(studyTimer);
                studyTimer = null;
            }
        }
        
        function updateStudyTimerDisplay() {
            const timerEl = document.getElementById('study-timer');
            if (timerEl) {
                const mins = Math.floor(studyTimeLeft / 60);
                const secs = studyTimeLeft % 60;
                timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            }
        }
        
        function updateStudyStats(sessionLength) {
            const today = new Date().toDateString();
            let studyData = JSON.parse(localStorage.getItem('spotifyStudyStats') || '{}');
            
            if (!studyData[today]) {
                studyData[today] = { totalTime: 0, sessions: 0 };
            }
            
            studyData[today].totalTime += sessionLength;
            studyData[today].sessions += 1;
            
            localStorage.setItem('spotifyStudyStats', JSON.stringify(studyData));
            loadStudyStats();
        }
        
        function loadStudyStats() {
            try {
                const today = new Date().toDateString();
                const studyData = JSON.parse(localStorage.getItem('spotifyStudyStats') || '{}');
                const todayData = studyData[today] || { totalTime: 0, sessions: 0 };
                console.log('Loading study stats:', { today, todayData, studyData });
                
                const totalTimeEl = document.getElementById('total-study-time');
                const sessionsEl = document.getElementById('study-sessions');
                const streakEl = document.getElementById('current-streak');
                
                if (totalTimeEl) {
                    const hours = Math.floor(todayData.totalTime / 60);
                    const mins = todayData.totalTime % 60;
                    totalTimeEl.textContent = `${hours}h ${mins}m`;
                    console.log('Set total time:', `${hours}h ${mins}m`);
                }
                
                if (sessionsEl) {
                    sessionsEl.textContent = todayData.sessions;
                    console.log('Set sessions:', todayData.sessions);
                }
                
                if (streakEl) {
                    // Calculate streak
                    let streak = 0;
                    const dates = Object.keys(studyData).sort().reverse();
                    for (const date of dates) {
                        if (studyData[date] && studyData[date].sessions > 0) {
                            streak++;
                        } else {
                            break;
                        }
                    }
                    streakEl.textContent = streak;
                    console.log('Set streak:', streak);
                }
                
                // Calculate weekly stats
                const weeklyTotalEl = document.getElementById('weekly-total');
                const weeklyAverageEl = document.getElementById('weekly-average');
                
                if (weeklyTotalEl && weeklyAverageEl) {
                    const now = new Date();
                    let weeklyTotal = 0;
                    
                    // Get past 7 days including today
                    for (let i = 0; i < 7; i++) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        const dateStr = date.toDateString();
                        
                        if (studyData[dateStr]) {
                            weeklyTotal += studyData[dateStr].totalTime || 0;
                        }
                    }
                    
                    const weeklyHours = Math.floor(weeklyTotal / 60);
                    const weeklyMins = weeklyTotal % 60;
                    weeklyTotalEl.textContent = `${weeklyHours}h ${weeklyMins}m`;
                    
                    const dailyAverage = weeklyTotal / 7;
                    const avgHours = Math.floor(dailyAverage / 60);
                    const avgMins = Math.floor(dailyAverage % 60);
                    weeklyAverageEl.textContent = `${avgHours}h ${avgMins}m`;
                }
                
                // Populate daily breakdown
                const dailyBreakdownEl = document.getElementById('daily-breakdown');
                if (dailyBreakdownEl) {
                    const now = new Date();
                    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    let dailyHTML = '';
                    
                    for (let i = 6; i >= 0; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        const dateStr = date.toDateString();
                        const dayName = dayNames[date.getDay()];
                        
                        const dayData = studyData[dateStr] || { totalTime: 0, sessions: 0 };
                        const hours = Math.floor(dayData.totalTime / 60);
                        const mins = dayData.totalTime % 60;
                        
                        // Color based on study time
                        const totalMins = dayData.totalTime;
                        let bgColor = '#2a2a2a';
                        if (totalMins > 0) {
                            if (totalMins >= 120) bgColor = '#1db954'; // 2+ hours
                            else if (totalMins >= 60) bgColor = '#1ed760'; // 1-2 hours
                            else if (totalMins >= 30) bgColor = '#1fdf64'; // 30m-1h
                            else bgColor = '#4a4a4a'; // <30m
                        }
                        
                        dailyHTML += `
                            <div style="background:${bgColor};padding:0.5rem;border-radius:8px;text-align:center;">
                                <div style="font-size:0.7rem;opacity:0.8;">${dayName}</div>
                                <div style="font-size:0.8rem;font-weight:bold;">${hours}h ${mins}m</div>
                                <div style="font-size:0.6rem;opacity:0.7;">${dayData.sessions} sessions</div>
                            </div>
                        `;
                    }
                    
                    dailyBreakdownEl.innerHTML = dailyHTML;
                }
            } catch (error) {
                console.error('Error loading study stats:', error);
                // Set default values if there's an error
                const totalTimeEl = document.getElementById('total-study-time');
                const sessionsEl = document.getElementById('study-sessions');
                const streakEl = document.getElementById('current-streak');
                
                if (totalTimeEl) totalTimeEl.textContent = '0h 0m';
                if (sessionsEl) sessionsEl.textContent = '0';
                if (streakEl) streakEl.textContent = '0';
            }
        }
        
        // Additional helper functions
        async function playAllRecommendations() {
            if (window.currentRecommendations && window.currentRecommendations.length > 0) {
                const trackUris = window.currentRecommendations.map(t => `spotify:track:${t.id}`);
                if (spotifyPlayerReady && spotifyDeviceId) {
                    await fetch('https://api.spotify.com/v1/me/player/play?device_id=' + spotifyDeviceId, {
                        method: 'PUT',
                        headers: {
                            'Authorization': 'Bearer ' + spotifyAccessToken,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ uris: trackUris })
                    });
                    showSuccess('Playing recommended tracks!');
                }
            }
        }
        
        async function shuffleRecommendations() {
            if (window.currentRecommendations) {
                const shuffled = [...window.currentRecommendations].sort(() => Math.random() - 0.5);
                const trackUris = shuffled.map(t => `spotify:track:${t.id}`);
                if (spotifyPlayerReady && spotifyDeviceId) {
                    await fetch('https://api.spotify.com/v1/me/player/play?device_id=' + spotifyDeviceId, {
                        method: 'PUT',
                        headers: {
                            'Authorization': 'Bearer ' + spotifyAccessToken,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ uris: trackUris })
                    });
                    showSuccess('Shuffling recommended tracks!');
                }
            }
        }
        
        async function refreshRecommendations() {
            showSpotifyRecommendations();
        }
        
        async function addToLiked(trackId) {
            try {
                await fetch(`https://api.spotify.com/v1/me/tracks?ids=${trackId}`, {
                    method: 'PUT',
                    headers: { 'Authorization': 'Bearer ' + spotifyAccessToken }
                });
                showSuccess('Track added to your liked songs!');
            } catch (error) {
                showError('Failed to add track to liked songs');
            }
        }
        
        async function playSpotifyAlbum(albumId) {
            if (spotifyPlayerReady && spotifyDeviceId) {
                try {
                    await fetch('https://api.spotify.com/v1/me/player/play?device_id=' + spotifyDeviceId, {
                        method: 'PUT',
                        headers: {
                            'Authorization': 'Bearer ' + spotifyAccessToken,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ context_uri: `spotify:album:${albumId}` })
                    });
                    showSuccess('Playing album!');
                } catch (error) {
                    showError('Failed to play album');
                }
            }
        }
        
        window.showSpotifyRecommendations = showSpotifyRecommendations;
        window.startStudyTimer = startStudyTimer;
        window.stopStudyTimer = stopStudyTimer;
        window.playAllRecommendations = playAllRecommendations;
        window.shuffleRecommendations = shuffleRecommendations;
        window.refreshRecommendations = refreshRecommendations;
        window.addToLiked = addToLiked;
        window.playSpotifyAlbum = playSpotifyAlbum;

    </script>
</body>
</html>